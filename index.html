<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>å°èªæ‰“å­—ç·´ç¿’ | å°èªæ–‡æ‹å­—ç·´ç¿’ - å…è²»ç·šé ‚ç·´ç¿’å®¶ç§</title>
    <meta
      name="description"
      content="å…è²»é–‹æºçš„å°èªæ‰“å­—ç·´ç¿’å·¥å…·ï¼Œæ”¯æ´å°ç¾…ã€ç™½è©±å­—è¼¸å…¥ç·´ç¿’ã€‚æä¾›éš¨æ©Ÿä¾‹å¥ã€è‡ªè¨‚æ–‡æœ¬ã€æ–‡ç« ç·´ç¿’ç­‰å¤šç¨®æ¨¡å¼ï¼Œå¹«åŠ©æ‚¨æå‡å°èªæ‰“å­—é€Ÿåº¦èˆ‡æº–ç¢ºåº¦ã€‚é©åˆå­¸ç¿’å°èªæ–‡çš„æœ‹å‹ä½¿ç”¨ã€‚"
    />
    <meta
      name="keywords"
      content="å°èªæ‰“å­—ç·´ç¿’,è‡ºèªæ‰“å­—ç·´ç¿’,å°èªæ‰“å­—,è‡ºèªæ‰“å­—,å°èªæ‹å­—ç·´ç¿’,å°èªæ–‡æ‰“å­—,å°èªè¼¸å…¥ç·´ç¿’,å°ç¾…æ‰“å­—,ç™½è©±å­—æ‰“å­—,å°èªç·´ç¿’,å°èªå­¸ç¿’,æ‰“å­—ç·´ç¿’,typing practice"
    />
    <meta name="author" content="TÃ¢n KiÃ n-tiong" />
    <meta name="robots" content="index, follow" />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta
      property="og:title"
      content="å°èªæ‰“å­—ç·´ç¿’ | è‡ºèªæ‰“å­—ç·´ç¿’ | å°èªæ–‡æ‹å­—ç·´ç¿’"
    />
    <meta
      property="og:description"
      content="å…è²»é–‹æºçš„å°èªæ‰“å­—ç·´ç¿’å·¥å…·ï¼Œæ”¯æ´å°ç¾…ã€ç™½è©±å­—è¼¸å…¥ç·´ç¿’ã€‚æä¾›éš¨æ©Ÿä¾‹å¥ã€è‡ªè¨‚æ–‡æœ¬ã€æ–‡ç« ç·´ç¿’ç­‰å¤šç¨®æ¨¡å¼ï¼Œå¹«åŠ©æ‚¨æå‡å°èªæ‰“å­—é€Ÿåº¦èˆ‡æº–ç¢ºåº¦ã€‚"
    />
    <meta property="og:locale" content="zh_TW" />

    <!-- Twitter -->
    <meta name="twitter:card" content="summary" />
    <meta
      name="twitter:title"
      content="å°èªæ‰“å­—ç·´ç¿’ | è‡ºèªæ‰“å­—ç·´ç¿’ | å°èªæ–‡æ‹å­—ç·´ç¿’"
    />
    <meta
      name="twitter:description"
      content="å…è²»é–‹æºçš„å°èªæ‰“å­—ç·´ç¿’å·¥å…·ï¼Œæ”¯æ´å°ç¾…ã€ç™½è©±å­—è¼¸å…¥ç·´ç¿’ã€‚æä¾›éš¨æ©Ÿä¾‹å¥ã€è‡ªè¨‚æ–‡æœ¬ã€æ–‡ç« ç·´ç¿’ç­‰å¤šç¨®æ¨¡å¼ï¼Œå¹«åŠ©æ‚¨æå‡å°èªæ‰“å­—é€Ÿåº¦èˆ‡æº–ç¢ºåº¦ã€‚"
    />

    <!-- Structured Data (JSON-LD) -->
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "å°èªæ‰“å­—ç·´ç¿’",
        "alternateName": ["è‡ºèªæ‰“å­—ç·´ç¿’", "å°èªæ–‡æ‹å­—ç·´ç¿’"],
        "description": "å…è²»é–‹æºçš„å°èªæ‰“å­—ç·´ç¿’å·¥å…·ï¼Œæ”¯æ´å°ç¾…ã€ç™½è©±å­—è¼¸å…¥ç·´ç¿’ã€‚æä¾›éš¨æ©Ÿä¾‹å¥ã€è‡ªè¨‚æ–‡æœ¬ã€æ–‡ç« ç·´ç¿’ç­‰å¤šç¨®æ¨¡å¼ï¼Œå¹«åŠ©æ‚¨æå‡å°èªæ‰“å­—é€Ÿåº¦èˆ‡æº–ç¢ºåº¦ã€‚",
        "applicationCategory": "EducationalApplication",
        "operatingSystem": "Web Browser",
        "offers": {
          "@type": "Offer",
          "price": "0",
          "priceCurrency": "TWD"
        },
        "inLanguage": "zh-TW",
        "keywords": "å°èªæ‰“å­—ç·´ç¿’,è‡ºèªæ‰“å­—ç·´ç¿’,å°èªæ‰“å­—,è‡ºèªæ‰“å­—,å°èªæ‹å­—ç·´ç¿’,å°èªæ–‡æ‰“å­—,å°èªè¼¸å…¥ç·´ç¿’,å°ç¾…æ‰“å­—,ç™½è©±å­—æ‰“å­—,å°èªç·´ç¿’,å°èªå­¸ç¿’,æ‰“å­—ç·´ç¿’"
      }
    </script>

    <!-- 
      ç‰ˆæœ¬è™Ÿï¼šæ¯æ¬¡æ›´æ–°æ™‚è«‹ä¿®æ”¹ä¸‹æ–¹æ‰€æœ‰æª”æ¡ˆ URL ä¸­çš„ç‰ˆæœ¬è™Ÿï¼ˆv=1.0.0ï¼‰
      ä¾‹å¦‚ï¼šå°‡ v=1.0.0 æ”¹ç‚º v=1.0.1ï¼Œå³å¯å¼·åˆ¶ç€è¦½å™¨é‡æ–°è¼‰å…¥æ‰€æœ‰è³‡æº
    -->
    <link href="https://tauhu.tw/tauhu-oo.css" rel="stylesheet" />
    <link href="./style.css?v=1.0.2" rel="stylesheet" />
  </head>
  <body>
    <div class="container">
      <h1>ğŸ“ å°èªæ–‡æ‹å­—ç·´ç¿’</h1>

      <div class="setup-area" id="setupArea">
        <h2>ç·´ç¿’æ–‡æœ¬</h2>

        <div class="text-source-selection">
          <div class="source-options">
            <div class="source-option">
              <input
                type="radio"
                id="sourceRandom"
                name="textSource"
                value="random"
                checked
              />
              <label for="sourceRandom">éš¨æ©Ÿä¾‹å¥</label>
            </div>
            <div class="source-option">
              <input
                type="radio"
                id="sourceCustom"
                name="textSource"
                value="custom"
              />
              <label for="sourceCustom">è‡ªè¨‚æ–‡æœ¬</label>
            </div>
            <div class="source-option">
              <input
                type="radio"
                id="sourceArticle"
                name="textSource"
                value="article"
              />
              <label for="sourceArticle">æ–‡ç« ç·´ç¿’</label>
            </div>
          </div>
        </div>

        <!-- éš¨æ©Ÿä¾‹å¥è¨­å®š -->
        <div class="random-settings" id="randomSettings">
          <div
            style="
              display: grid;
              grid-template-columns: auto 1fr;
              gap: 10px 15px;
              align-items: center;
              margin-top: 0;
            "
          >
            <label style="color: var(--caption-text); text-align: right"
              >ä¾‹å¥æ•¸é‡ï¼š</label
            >
            <div style="display: flex; gap: 10px; align-items: center">
              <input
                type="number"
                id="randomCount"
                value="5"
                min="1"
                max="50"
                style="
                  width: 80px;
                  padding: 8px;
                  border: 1px solid var(--borders);
                  border-radius: 3px;
                  font-size: 14px;
                  background: white;
                  color: var(--primary-text);
                "
              />
              <span style="color: var(--caption-text); font-size: 13px"
                >ï¼ˆä¾‹å¥æ”æºè‡ª<a
                  href="https://sutian.moe.edu.tw/und-hani/"
                  target="_blank"
                  >æ•™è‚²éƒ¨è‡ºç£å°èªå¸¸ç”¨è©è¾­å…¸</a
                >ï¼‰</span
              >
            </div>

            <label style="color: var(--caption-text); text-align: right"
              >Seedï¼š</label
            >
            <div style="display: flex; gap: 10px; align-items: center">
              <input
                type="text"
                id="seedInput"
                placeholder=""
                style="
                  width: 80px;
                  padding: 8px;
                  border: 1px solid var(--borders);
                  border-radius: 3px;
                  font-size: 14px;
                  background: white;
                  color: var(--primary-text);
                "
              />
              <span style="color: var(--caption-text); font-size: 13px"
                >ï¼ˆä»æ¬¾çš„Seedæœƒå‡ºç¾ä»æ¬¾çš„é¡Œç›®ï¼‰</span
              >
            </div>
          </div>
        </div>

        <!-- è‡ªé¸æ–‡æœ¬è¨­å®š -->
        <div
          class="article-selection"
          id="articleSelection"
          style="display: none"
        >
          <div class="article-search-section">
            <input
              type="text"
              id="articleSearchInput"
              class="article-search-input"
              placeholder="æ£æ¨™é¡ŒæŠ‘æ˜¯æ¨™ç±¤..."
            />
            <div
              class="article-filter-info"
              id="articleFilterInfo"
              style="display: none"
            >
              <span id="filterText"></span>
              <button class="clear-filter-btn" id="clearFilterBtn">
                Clear
              </button>
            </div>
          </div>
          <div class="article-intro-text">
            ç›®å‰æ”ç¸½æ”¶éŒ„
            <span id="articleCount">0</span>
            ç¯‡æ–‡ç« <br />æ„Ÿè¬å„ä½ä½œè€…æˆæ¬Šæœ¬ç¶²ç«™äºˆé€å®¶ç·´ç¿’æ‹å­—ï¼Œæ–‡ç« ç‰ˆæ¬Šæ­¸å±¬åŸå§‹ä¾†æºï¼Œè‹¥æ˜¯ä½ é¡˜æ„æä¾›ä½ çš„ä½œå“ï¼Œæ­¡è¿æ·»<a
              href="https://forms.gle/3apYPbSQ6gNDSZrs9"
              target="_blank"
              rel="noopener noreferrer"
              >é€™ä¸ªè¡¨å–®</a
            >ã€‚
          </div>
          <div class="article-list" id="articleList">
            <!-- æ–‡ç« åˆ—è¡¨å°‡ç”± JavaScript å‹•æ…‹ç”Ÿæˆ -->
          </div>
        </div>

        <!-- è‡ªè¨‚æ–‡æœ¬è¨­å®š -->
        <div class="custom-settings" id="customSettings" style="display: none">
          <div class="text-type-selection" style="margin-bottom: 20px">
            <div class="text-type-options">
              <div class="text-type-option">
                <input
                  type="radio"
                  id="textTypeMapped"
                  name="textType"
                  value="mapped"
                  checked
                />
                <label for="textTypeMapped">æ¼¢ç¾…å°æ‡‰æ–‡æœ¬</label>
              </div>
              <div class="text-type-option">
                <input
                  type="radio"
                  id="textTypeSingle"
                  name="textType"
                  value="single"
                />
                <label for="textTypeSingle">å–®ä¸€æ–‡æœ¬</label>
              </div>
            </div>
          </div>

          <!-- æ¼¢ç¾…å°æ‡‰æ¨¡å¼ï¼šå…©å€‹è¼¸å…¥æ¡† -->
          <div id="mappedInputs">
            <h3>æ¼¢ç¾…æ–‡æœ¬ï¼š</h3>
            <textarea
              id="hanjiText"
              placeholder="è«‹è¼¸å…¥æ¬²ç·´ç¿’çš„æ¼¢ç¾…æ–‡æœ¬"
            ></textarea>

            <h3>ç¾…é¦¬å­—æ–‡æœ¬ï¼š</h3>
            <textarea
              id="tailoText"
              placeholder="è«‹è¼¸å…¥å°æ‡‰çš„ç¾…é¦¬å­—æ–‡æœ¬"
            ></textarea>
          </div>

          <!-- å–®ä¸€æ–‡æœ¬æ¨¡å¼ï¼šä¸€å€‹è¼¸å…¥æ¡† -->
          <div id="singleInput" style="display: none">
            <h3>ç·´ç¿’æ–‡æœ¬ï¼š</h3>
            <textarea
              id="singleText"
              placeholder="è«‹è¼¸å…¥æ¬²ç·´ç¿’çš„æ–‡æœ¬"
            ></textarea>
          </div>
        </div>

        <div id="modeSelectionSection">
          <h2>ç·´ç¿’æ¨¡å¼</h2>
          <div class="mode-selection">
            <div class="mode-options">
              <div class="mode-option">
                <input
                  type="radio"
                  id="modeHanji"
                  name="inputMode"
                  value="hanji"
                  checked
                />
                <label for="modeHanji">ç·´ç¿’æ‹æ¼¢å­—<br /></label>
              </div>
              <div class="mode-option">
                <input
                  type="radio"
                  id="modeTailo"
                  name="inputMode"
                  value="tailo"
                />
                <label for="modeTailo">ç·´ç¿’æ‹ç¾…é¦¬å­—<br /></label>
              </div>
            </div>
          </div>
        </div>

        <!-- éš¨æ©Ÿä¾‹å¥æ¨¡å¼çš„ç¾…é¦¬å­—ç³»çµ±é¸é … -->
        <div id="randomRomanizationSection" style="display: none">
          <h2>ç¾…é¦¬å­—ç³»çµ±</h2>
          <div class="romanization-selection">
            <div class="romanization-options">
              <div class="romanization-option">
                <input
                  type="radio"
                  id="systemTailoRandom"
                  name="romanizationSystemRandom"
                  value="tailo"
                  checked
                />
                <label for="systemTailoRandom">å°ç¾…</label>
              </div>
              <div class="romanization-option">
                <input
                  type="radio"
                  id="systemPOJRandom"
                  name="romanizationSystemRandom"
                  value="poj"
                />
                <label for="systemPOJRandom">ç™½è©±å­—</label>
              </div>
            </div>
          </div>
        </div>

        <!-- è‡ªè¨‚æ–‡æœ¬æ¨¡å¼çš„ç¾…é¦¬å­—è½‰æ›å·¥å…· -->
        <div id="customRomanizationSection" style="display: none">
          <h2>ç¾…é¦¬å­—è½‰æ›å®¶ç§</h2>
          <div
            style="
              color: var(--caption-text);
              font-size: 13px;
              margin-bottom: 10px;
            "
          >
            å…±ä½ çš„æ–‡æœ¬è½‰æ›åšæ¬²æ„›çš„ç¾…é¦¬å­—ç³»çµ±
          </div>
          <div class="romanization-conversion">
            <button class="conversion-btn" id="convertToTailoBtn">
              è½‰æ›åšå°ç¾…
            </button>
            <button class="conversion-btn" id="convertToPOJBtn">
              è½‰æ›åšç™½è©±å­—
            </button>
          </div>
        </div>

        <div class="button-group">
          <button class="start-btn" id="startBtn">é–‹å§‹ç·´ç¿’</button>
        </div>
      </div>

      <div class="stats-bar" id="statsBar">
        <div class="stat-item">
          <span class="stat-label time-label">æ™‚é–“</span>
          <span class="stat-value" id="timeDisplay">0:00</span>
        </div>
        <div class="stat-item">
          <span class="stat-label correct-label">æ­£ç¢º</span>
          <span class="stat-value correct-value" id="correctDisplay">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label error-label">éŒ¯èª¤</span>
          <span class="stat-value error-value" id="errorDisplay">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label missed-label">ç„¡æ‹</span>
          <span class="stat-value missed-value" id="missedDisplay">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label speed-label">é€Ÿåº¦</span>
          <span class="stat-value speed-value" id="speedDisplay">0</span>
        </div>
      </div>

      <div class="practice-area" id="practiceArea">
        <div class="info-section">
          <input
            type="text"
            class="prep-input"
            id="prepInput"
            placeholder="è«‹å…±ä½ çš„è¼¸å…¥æ³•æ’¨å¥½å‹¢ï¼Œæº–å‚™å¥½å‹¢æ¤ Enter é–‹å§‹ç·´ç¿’"
            autocomplete="off"
            spellcheck="false"
          />
        </div>

        <hr />

        <div id="typingSections"></div>

        <button class="finish-btn" id="finishBtn">çµæŸç·´ç¿’ã€çœ‹æˆç¸¾</button>
      </div>

      <div class="result-modal" id="resultModal">
        <div class="result-content">
          <h2>ğŸ‰ ç·´ç¿’å®Œæˆï¼</h2>
          <div class="result-stats" id="resultStats"></div>
          <button class="close-btn" id="closeBtn">é—œé–‰è¦–çª—</button>
        </div>
      </div>
    </div>
    <footer class="site-footer">
      <div class="footer-content">
        <div class="footer-link">
          <a
            href="https://kiantiong.com/"
            target="_blank"
            rel="noopener noreferrer"
            >TÃ¢n KiÃ n-tiong</a
          >
          |
          <a
            href="https://github.com/luke871016/taigi_typing"
            target="_blank"
            rel="noopener noreferrer"
            >Github</a
          >
        </div>
      </div>
    </footer>
    <!-- å¤–éƒ¨ JavaScript æª”æ¡ˆï¼ˆå·²åŠ å…¥ç‰ˆæœ¬åƒæ•¸ä»¥é¿å…å¿«å–ï¼‰ -->
    <script src="./exampleSentences.js?v=1.0.0"></script>
    <script src="./tailoToPOJMapping.js?v=1.0.0"></script>
    <script src="./articles.js?v=1.0.92"></script>
    <script>
      // å…¨å±€å˜é‡
      let hanjiParagraphs = [];
      let tailoParagraphs = [];
      let paragraphs = [];
      let inputMode = "hanji";
      let isSingleTextMode = false; // è¨˜éŒ„æ˜¯å¦ç‚ºå–®ä¸€æ–‡æœ¬æ¨¡å¼
      let stats = {
        startTime: null,
        elapsedTime: 0,
        correct: 0,
        errors: 0,
        missed: 0,
        totalChars: 0,
      };
      let timerInterval = null;
      let isTypingStarted = false;
      let isComposing = false;
      let isRandomMode = false; // è¨˜éŒ„æ˜¯å¦ç‚ºéš¨æ©Ÿæ¨¡å¼
      let currentRomanizationSystem = "tailo"; // è¨˜éŒ„ç•¶å‰ç¾…é¦¬å­—ç³»çµ±ï¼ˆtailo æˆ– pojï¼‰
      let allowPaste = false; // é™¤éŒ¯ç”¨ï¼šæ˜¯å¦å…è¨±è²¼ä¸Šï¼ˆé è¨­ç¦æ­¢ï¼‰

      // æ•™å…¸ä¾‹å¥æ•¸æ“šå·²ç§»è‡³ exampleSentences.js æª”æ¡ˆ
      // å°ç¾…è½‰ç™½è©±å­—å°æ‡‰è¡¨å·²ç§»è‡³ tailoToPOJMapping.js æª”æ¡ˆ

      // ç°¡å–®çš„ç¨®å­éš¨æ©Ÿæ•¸ç”Ÿæˆå™¨ï¼ˆLCGç®—æ³•ï¼‰
      class SeededRandom {
        constructor(seed) {
          this.seed = seed % 2147483647;
          if (this.seed <= 0) this.seed += 2147483646;
        }

        next() {
          this.seed = (this.seed * 48271) % 2147483647;
          return (this.seed - 1) / 2147483646;
        }
      }

      // å­—ä¸²è½‰æ›ç‚ºæ•¸å­—ç¨®å­
      function stringToSeed(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = (hash << 5) - hash + char;
          hash = hash & hash; // Convert to 32bit integer
        }
        return Math.abs(hash);
      }

      // ä½¿ç”¨ç¨®å­æ‰“äº‚æ•¸çµ„
      function shuffleWithSeed(array, seed) {
        const rng = new SeededRandom(seed);
        const shuffled = [...array];

        // Fisher-Yates shuffle with seeded random
        for (let i = shuffled.length - 1; i > 0; i--) {
          const j = Math.floor(rng.next() * (i + 1));
          [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }

        return shuffled;
      }

      // ç”¨æ–¼è¨˜éŒ„ç•¶å‰ç·´ç¿’çš„ç¨®å­ç¢¼
      let currentSeed = null;

      // å»ºç«‹ç™½è©±å­—è½‰å°ç¾…çš„åå‘æ˜ å°„
      const pojToTailoMapping = {};
      for (const [tailo, poj] of Object.entries(tailoToPOJMapping)) {
        pojToTailoMapping[poj] = tailo;
      }

      // å°ç¾…è½‰ç™½è©±å­—è½‰æ›å‡½æ•¸
      function convertTailoToPOJ(text) {
        if (!text) return text;

        let result = "";
        let i = 0;

        while (i < text.length) {
          const char = text[i];

          // è™•ç†ç©ºæ ¼å’Œæ¨™é»ï¼šç›´æ¥ä¿ç•™
          if (/\s/.test(char) || isPunctuation(char)) {
            result += char;
            i++;
            continue;
          }

          // è™•ç†æ¼¢å­—ï¼ˆåŒ…æ‹¬ä»£ç†å°ï¼‰
          const hanjiMatch = getNextHanjiChar(text, i);
          if (hanjiMatch) {
            result += hanjiMatch.char;
            i += hanjiMatch.length;
            continue;
          }

          // è™•ç†æ•¸å­—
          if (/\d/.test(char)) {
            let numberStr = "";
            while (i < text.length && /\d/.test(text[i])) {
              numberStr += text[i];
              i++;
            }
            result += numberStr;
            continue;
          }

          // å¦å‰‡è¦–ç‚ºç¾…é¦¬å­—ï¼šæ”¶é›†åˆ°ç©ºæ ¼ã€æ¨™é»ã€æ¼¢å­—æˆ–æ•¸å­—ç‚ºæ­¢
          let word = "";
          while (i < text.length) {
            const c = text[i];

            // é‡åˆ°ç©ºæ ¼ã€æ¨™é»ã€æ¼¢å­—æˆ–æ•¸å­—å°±åœæ­¢
            if (
              /\s/.test(c) ||
              isPunctuation(c) ||
              getNextHanjiChar(text, i) ||
              /\d/.test(c)
            ) {
              break;
            }

            word += c;
            i++;
          }

          // è½‰æ›ç¾…é¦¬å­—è©
          if (word.length > 0) {
            result += convertWord(word);
          }
        }

        return result;
      }

      // è½‰æ›å–®å€‹è©ï¼ˆå¯èƒ½åŒ…å«å¤šå€‹éŸ³ç¯€ï¼‰
      function convertWord(word) {
        if (!word || word.length === 0) return word;

        // è™•ç†é€£å­—ç¬¦è™Ÿåˆ†éš”çš„éŸ³ç¯€
        // å…ˆè™•ç†è¼•è²ç¬¦è™Ÿ --
        const parts = word.split(/(--)/);
        const converted = parts.map((part) => {
          if (part === "--") {
            return "--"; // è¼•è²ç¬¦è™Ÿä¿æŒ
          }

          // æŒ‰å–®é€£å­—ç¬¦è™Ÿåˆ†å‰²
          const syllables = part.split(/(-)/);
          return syllables
            .map((syllable) => {
              if (syllable === "-") {
                return "-"; // é€£å­—ç¬¦è™Ÿä¿æŒ
              }
              return convertSyllable(syllable);
            })
            .join("");
        });

        return converted.join("");
      }

      // è½‰æ›å–®å€‹éŸ³ç¯€ï¼ˆè€ƒæ…®å¤§å°å¯«ï¼‰
      function convertSyllable(syllable) {
        if (!syllable || syllable.length === 0) return syllable;

        // æª¢æŸ¥é¦–å­—æ¯æ˜¯å¦å¤§å¯«
        const isCapitalized =
          syllable.length > 0 &&
          syllable[0] === syllable[0].toUpperCase() &&
          syllable[0] !== syllable[0].toLowerCase();

        // è½‰æ›ç‚ºå°å¯«é€²è¡ŒæŸ¥æ‰¾
        const lowerSyllable = syllable.toLowerCase();

        if (tailoToPOJMapping[lowerSyllable]) {
          const pojSyllable = tailoToPOJMapping[lowerSyllable];

          // å¦‚æœåŸéŸ³ç¯€é¦–å­—æ¯å¤§å¯«ï¼Œçµæœä¹Ÿè¦å¤§å¯«
          if (isCapitalized && pojSyllable.length > 0) {
            return pojSyllable.charAt(0).toUpperCase() + pojSyllable.slice(1);
          }

          return pojSyllable;
        }

        // å¦‚æœæ²’æœ‰å°æ‡‰ï¼Œè¿”å›åŸéŸ³ç¯€
        return syllable;
      }

      // ç™½è©±å­—è½‰å°ç¾…è½‰æ›å‡½æ•¸
      function convertPOJToTailo(text) {
        if (!text) return text;

        let result = "";
        let i = 0;

        while (i < text.length) {
          const char = text[i];

          // è™•ç†ç©ºæ ¼å’Œæ¨™é»ï¼šç›´æ¥ä¿ç•™
          if (/\s/.test(char) || isPunctuation(char)) {
            result += char;
            i++;
            continue;
          }

          // è™•ç†æ¼¢å­—ï¼ˆåŒ…æ‹¬ä»£ç†å°ï¼‰
          const hanjiMatch = getNextHanjiChar(text, i);
          if (hanjiMatch) {
            result += hanjiMatch.char;
            i += hanjiMatch.length;
            continue;
          }

          // è™•ç†æ•¸å­—
          if (/\d/.test(char)) {
            let numberStr = "";
            while (i < text.length && /\d/.test(text[i])) {
              numberStr += text[i];
              i++;
            }
            result += numberStr;
            continue;
          }

          // å¦å‰‡è¦–ç‚ºç¾…é¦¬å­—ï¼šæ”¶é›†åˆ°ç©ºæ ¼ã€æ¨™é»ã€æ¼¢å­—æˆ–æ•¸å­—ç‚ºæ­¢
          let word = "";
          while (i < text.length) {
            const c = text[i];

            // é‡åˆ°ç©ºæ ¼ã€æ¨™é»ã€æ¼¢å­—æˆ–æ•¸å­—å°±åœæ­¢
            if (
              /\s/.test(c) ||
              isPunctuation(c) ||
              getNextHanjiChar(text, i) ||
              /\d/.test(c)
            ) {
              break;
            }

            word += c;
            i++;
          }

          // è½‰æ›ç¾…é¦¬å­—è©
          if (word.length > 0) {
            result += convertPOJWord(word);
          }
        }

        return result;
      }

      // è½‰æ›å–®å€‹ç™½è©±å­—è©ï¼ˆå¯èƒ½åŒ…å«å¤šå€‹éŸ³ç¯€ï¼‰
      function convertPOJWord(word) {
        if (!word || word.length === 0) return word;

        // è™•ç†é€£å­—ç¬¦è™Ÿåˆ†éš”çš„éŸ³ç¯€
        // å…ˆè™•ç†è¼•è²ç¬¦è™Ÿ --
        const parts = word.split(/(--)/);
        const converted = parts.map((part) => {
          if (part === "--") {
            return "--"; // è¼•è²ç¬¦è™Ÿä¿æŒ
          }

          // æŒ‰å–®é€£å­—ç¬¦è™Ÿåˆ†å‰²
          const syllables = part.split(/(-)/);
          return syllables
            .map((syllable) => {
              if (syllable === "-") {
                return "-"; // é€£å­—ç¬¦è™Ÿä¿æŒ
              }
              return convertPOJSyllable(syllable);
            })
            .join("");
        });

        return converted.join("");
      }

      // è½‰æ›å–®å€‹ç™½è©±å­—éŸ³ç¯€ï¼ˆè€ƒæ…®å¤§å°å¯«ï¼‰
      function convertPOJSyllable(syllable) {
        if (!syllable || syllable.length === 0) return syllable;

        // å…ˆè™•ç†ç™½è©±å­—é¼»éŸ³ hâ¿ å’Œ â¿h â†’ å°ç¾… nnh
        // æª¢æŸ¥æ˜¯å¦åŒ…å« hâ¿ æˆ– â¿hï¼ˆä¸å€åˆ†å¤§å°å¯«ï¼‰
        let processedSyllable = syllable;

        // è™•ç† hâ¿ â†’ nnh
        if (/hâ¿/i.test(processedSyllable)) {
          processedSyllable = processedSyllable.replace(/hâ¿/gi, (match) => {
            // ä¿æŒåŸæœ¬çš„å¤§å°å¯«
            if (match === "Hâ¿") return "Nnh";
            if (match === "hâ¿") return "nnh";
            return "nnh"; // é è¨­
          });
        }

        // è™•ç† â¿h â†’ nnh
        if (/â¿h/i.test(processedSyllable)) {
          processedSyllable = processedSyllable.replace(/â¿h/gi, (match) => {
            // ä¿æŒåŸæœ¬çš„å¤§å°å¯«
            if (match === "â¿H") return "Nnh";
            if (match === "â¿h") return "nnh";
            return "nnh"; // é è¨­
          });
        }

        // æª¢æŸ¥é¦–å­—æ¯æ˜¯å¦å¤§å¯«
        const isCapitalized =
          processedSyllable.length > 0 &&
          processedSyllable[0] === processedSyllable[0].toUpperCase() &&
          processedSyllable[0] !== processedSyllable[0].toLowerCase();

        // è½‰æ›ç‚ºå°å¯«é€²è¡ŒæŸ¥æ‰¾
        const lowerSyllable = processedSyllable.toLowerCase();

        if (pojToTailoMapping[lowerSyllable]) {
          const tailoSyllable = pojToTailoMapping[lowerSyllable];

          // å¦‚æœåŸéŸ³ç¯€é¦–å­—æ¯å¤§å¯«ï¼Œçµæœä¹Ÿè¦å¤§å¯«
          if (isCapitalized && tailoSyllable.length > 0) {
            return (
              tailoSyllable.charAt(0).toUpperCase() + tailoSyllable.slice(1)
            );
          }

          return tailoSyllable;
        }

        // å¦‚æœæ²’æœ‰å°æ‡‰ï¼Œè¿”å›è™•ç†éé¼»éŸ³çš„éŸ³ç¯€
        return processedSyllable;
      }

      // Unicode æ­£è¦åŒ–å‡½æ•¸ï¼šå°‡æ–‡æœ¬æ­£è¦åŒ–ç‚º NFC å½¢å¼ä»¥ä¾¿æ¯”è¼ƒ
      function normalizeUnicode(text) {
        if (!text) return text;
        // NFC: Canonical Composition - çµ„åˆå½¢å¼
        return text.normalize("NFC");
      }

      // ç™½è©±å­— hâ¿/â¿h æ¨™æº–åŒ–å‡½æ•¸ï¼šå°‡ â¿h çµ±ä¸€è½‰æ›ç‚º hâ¿
      function normalizePOJNasal(text) {
        if (!text) return text;
        // å°‡ â¿h æ›¿æ›ç‚º hâ¿ï¼ˆä¸å€åˆ†å¤§å°å¯«ï¼‰
        return text.replace(/â¿h/gi, (match) => {
          // ä¿æŒåŸæœ¬çš„å¤§å°å¯«
          if (match === "â¿H") return "Hâ¿";
          if (match === "â¿h") return "hâ¿";
          return "hâ¿"; // é è¨­
        });
      }

      // ç¬¬å…«èª¿ i æ¨™æº–åŒ–å‡½æ•¸ï¼šå°‡ Ä±(U+0131) + â—ŒÌ(U+030D) çµ±ä¸€è½‰æ›ç‚º i(U+0069) + â—ŒÌ(U+030D)
      function normalizeEighthToneI(text) {
        if (!text) return text;
        // ä½¿ç”¨æ­£å‰‡è¡¨é”å¼åŒ¹é… Ä±(U+0131) å¾Œé¢è·Ÿè‘— â—ŒÌ(U+030D) çš„æƒ…æ³
        // ç”±æ–¼æ˜¯çµ„åˆå­—ç¬¦ï¼Œéœ€è¦åŒ¹é…å­—ç´ ç°‡ï¼ˆgrapheme clusterï¼‰
        // å…ˆå°‡æ–‡æœ¬åˆ†è§£ç‚ºå­—ç´ ç°‡ï¼Œç„¶å¾Œæ›¿æ›
        const graphemes = splitIntoGraphemes(text);
        return graphemes
          .map((grapheme) => {
            // æª¢æŸ¥æ˜¯å¦ç‚º Ä±(U+0131) + â—ŒÌ(U+030D) çš„çµ„åˆ
            // æª¢æŸ¥ç¬¬ä¸€å€‹å­—ç¬¦æ˜¯å¦ç‚º Ä±(U+0131)ï¼Œä¸”åŒ…å« â—ŒÌ(U+030D)
            if (
              grapheme.length > 0 &&
              grapheme.charCodeAt(0) === 0x0131 &&
              grapheme.includes("\u030D")
            ) {
              // å°‡ Ä± æ›¿æ›ç‚º iï¼Œä¿ç•™å…¶ä»–çµ„åˆå­—ç¬¦ï¼ˆåŒ…æ‹¬ â—ŒÌï¼‰
              return "\u0069" + grapheme.substring(1);
            }
            return grapheme;
          })
          .join("");
      }

      // ç¶œåˆæ­£è¦åŒ–å‡½æ•¸ï¼šåŒæ™‚è™•ç† Unicodeã€ç™½è©±å­—é¼»éŸ³å’Œç¬¬å…«èª¿ i è®Šé«”
      function normalizeForComparison(text, isPOJ = false) {
        if (!text) return text;
        let normalized = normalizeUnicode(text);
        // è™•ç†ç¬¬å…«èª¿ i è®Šé«”ï¼ˆåœ¨æ‰€æœ‰æƒ…æ³ä¸‹éƒ½éœ€è¦è™•ç†ï¼‰
        normalized = normalizeEighthToneI(normalized);
        if (isPOJ) {
          normalized = normalizePOJNasal(normalized);
        }
        return normalized;
      }

      // æ­£å‰‡è¡¨é”å¼è½‰ç¾©å‡½æ•¸
      function escapeRegExp(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }

      // è·å–éšæœºä¾‹å¥
      function getRandomSentences(count, seedInput = null) {
        let seed;

        if (seedInput && seedInput.trim() !== "") {
          // ä½¿ç”¨ç”¨æˆ¶æä¾›çš„ç¨®å­ç¢¼
          seed = stringToSeed(seedInput.trim());
          currentSeed = seedInput.trim();
        } else {
          // ç”Ÿæˆéš¨æ©Ÿç¨®å­ç¢¼ï¼ˆä½¿ç”¨æ™‚é–“æˆ³ï¼‰
          const randomSeed =
            Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
          seed = stringToSeed(randomSeed);
          currentSeed = randomSeed;
        }

        const shuffled = shuffleWithSeed(exampleSentences, seed);
        return shuffled.slice(0, Math.min(count, exampleSentences.length));
      }

      // æª¢æŸ¥æ˜¯å¦ç‚ºæ¼¢ç¾…å°æ‡‰æ¨¡å¼
      function isHanloMappingMode() {
        const textSource = document.querySelector(
          'input[name="textSource"]:checked'
        )?.value;
        // éš¨æ©Ÿä¾‹å¥æ¨¡å¼é è¨­ç‚ºæ¼¢ç¾…å°æ‡‰
        if (textSource === "random") {
          return true;
        }
        // è‡ªè¨‚æ–‡æœ¬æ¨¡å¼ï¼šæª¢æŸ¥æ–‡æœ¬é¡å‹é¸é …
        const textType = document.querySelector(
          'input[name="textType"]:checked'
        )?.value;
        return textType === "mapped";
      }

      // åˆ‡æ›æ–‡æœ¬ä¾†æº
      function toggleTextSource() {
        const textSource = document.querySelector(
          'input[name="textSource"]:checked'
        ).value;
        const randomSettings = document.getElementById("randomSettings");
        const customSettings = document.getElementById("customSettings");
        const articleSelection = document.getElementById("articleSelection");
        const randomRomanizationSection = document.getElementById(
          "randomRomanizationSection"
        );
        const customRomanizationSection = document.getElementById(
          "customRomanizationSection"
        );
        const modeSelectionSection = document.getElementById(
          "modeSelectionSection"
        );

        const startBtn = document.getElementById("startBtn");
        const buttonGroup = document.querySelector(".button-group");

        if (textSource === "random") {
          // éš¨æ©Ÿä¾‹å¥æ¨¡å¼
          randomSettings.style.display = "block";
          customSettings.style.display = "none";
          articleSelection.style.display = "none";
          randomRomanizationSection.style.display = "block";
          customRomanizationSection.style.display = "none";
          modeSelectionSection.style.display = "block";
          buttonGroup.style.display = "flex";
        } else if (textSource === "article") {
          // è‡ªé¸æ–‡æœ¬æ¨¡å¼
          randomSettings.style.display = "none";
          customSettings.style.display = "none";
          articleSelection.style.display = "block";
          randomRomanizationSection.style.display = "none";
          customRomanizationSection.style.display = "none";
          modeSelectionSection.style.display = "none";
          buttonGroup.style.display = "none"; // éš±è—é–‹å§‹ç·´ç¿’æŒ‰éˆ•

          // é‡ç½®æœå°‹å’Œéæ¿¾ç‹€æ…‹
          currentSearchQuery = "";
          currentFilterTag = "";
          const searchInput = document.getElementById("articleSearchInput");
          if (searchInput) {
            searchInput.value = "";
          }

          // é¡¯ç¤ºæ–‡ç« åˆ—è¡¨
          displayArticleList();
        } else {
          // è‡ªè¨‚æ–‡æœ¬æ¨¡å¼
          randomSettings.style.display = "none";
          customSettings.style.display = "block";
          articleSelection.style.display = "none";
          randomRomanizationSection.style.display = "none";
          customRomanizationSection.style.display = "block";
          buttonGroup.style.display = "flex";

          // æ›´æ–°æ–‡æœ¬é¡å‹é¡¯ç¤ºç‹€æ…‹
          toggleTextType();
        }
      }

      // çµ±è¨ˆæ–‡ç« éŸ³ç¯€æ•¸
      function countArticleSyllables(article) {
        if (article.type === "mapped") {
          // æ¼¢ç¾…å°æ‡‰æ–‡æœ¬ï¼šçµ±è¨ˆå°ç¾…æ–‡æœ¬çš„éŸ³ç¯€æ•¸
          const tailoText = article.tailo;
          const analysis = analyzeTailoText(tailoText);
          let totalSyllables = 0;
          analysis.forEach((item) => {
            if (!item.isPunctuation) {
              totalSyllables += item.syllables;
            }
          });
          return totalSyllables;
        } else {
          // å–®ä¸€æ–‡æœ¬ï¼šéœ€è¦åˆ¤æ–·æ˜¯æ¼¢å­—é‚„æ˜¯ç¾…é¦¬å­—
          const content = article.content;
          let totalSyllables = 0;
          let i = 0;

          while (i < content.length) {
            const char = content[i];

            // è·³éç©ºæ ¼
            if (char === " ") {
              i++;
              continue;
            }

            // è·³éæ¨™é»ç¬¦è™Ÿ
            if (isPunctuation(char)) {
              i++;
              continue;
            }

            // æª¢æŸ¥æ˜¯å¦ç‚ºæ¼¢å­—
            const hanjiMatch = getNextHanjiChar(content, i);
            if (hanjiMatch) {
              // æ˜¯æ¼¢å­—ï¼šæ¯å€‹æ¼¢å­—ç®—ä¸€å€‹éŸ³ç¯€
              totalSyllables++;
              i += hanjiMatch.length;
              continue;
            }

            // æª¢æŸ¥æ˜¯å¦ç‚ºæ•¸å­—
            if (/\d/.test(char)) {
              // æ•¸å­—ç®—ä¸€å€‹éŸ³ç¯€
              totalSyllables++;
              while (i < content.length && /\d/.test(content[i])) {
                i++;
              }
              continue;
            }

            // å¦å‰‡è¦–ç‚ºç¾…é¦¬å­—ï¼šæ”¶é›†åˆ°ç©ºæ ¼ã€æ¨™é»æˆ–æ¼¢å­—ç‚ºæ­¢
            let word = "";
            while (i < content.length) {
              const c = content[i];
              if (
                c === " " ||
                isPunctuation(c) ||
                getNextHanjiChar(content, i)
              ) {
                break;
              }
              word += c;
              i++;
            }

            // è¨ˆç®—ç¾…é¦¬å­—è©çš„éŸ³ç¯€æ•¸
            if (word.length > 0) {
              totalSyllables += countSyllables(word);
            }
          }

          return totalSyllables;
        }
      }

      // æˆªå–æ–‡æœ¬åˆ°æŒ‡å®šéŸ³ç¯€æ•¸ï¼ˆç”¨æ–¼é è¦½ï¼‰
      function truncateBySyllables(text, maxSyllables, isTailo = false) {
        if (!text) return "";

        if (isTailo) {
          // å°ç¾…æ–‡æœ¬ï¼šåˆ†æéŸ³ç¯€ä¸¦æˆªå–
          const analysis = analyzeTailoText(text);
          let syllableCount = 0;
          let result = "";

          for (const item of analysis) {
            if (syllableCount >= maxSyllables) break;

            if (item.isPunctuation) {
              // æ¨™é»ç¬¦è™Ÿä¸ç®—éŸ³ç¯€ï¼Œä½†åŒ…å«åœ¨çµæœä¸­
              result += item.text;
            } else {
              const remainingSyllables = maxSyllables - syllableCount;
              if (item.syllables <= remainingSyllables) {
                result +=
                  (result && !isPunctuation(result[result.length - 1])
                    ? " "
                    : "") + item.text;
                syllableCount += item.syllables;
              } else {
                // å¦‚æœé€™å€‹è©çš„éŸ³ç¯€æ•¸è¶…éå‰©é¤˜é¡åº¦ï¼Œéœ€è¦æˆªæ–·
                // é€™è£¡ç°¡åŒ–è™•ç†ï¼ŒåªåŒ…å«å®Œæ•´çš„è©
                break;
              }
            }
          }

          return result.trim() + "...";
        } else {
          // å–®ä¸€æ–‡æœ¬ï¼šéœ€è¦åˆ¤æ–·æ˜¯æ¼¢å­—é‚„æ˜¯ç¾…é¦¬å­—
          let syllableCount = 0;
          let result = "";
          let i = 0;

          while (i < text.length && syllableCount < maxSyllables) {
            const char = text[i];

            // è·³éç©ºæ ¼
            if (char === " ") {
              result += char;
              i++;
              continue;
            }

            // æ¨™é»ç¬¦è™Ÿä¸ç®—éŸ³ç¯€ï¼Œä½†åŒ…å«åœ¨çµæœä¸­
            if (isPunctuation(char)) {
              result += char;
              i++;
              continue;
            }

            // æª¢æŸ¥æ˜¯å¦ç‚ºæ¼¢å­—
            const hanjiMatch = getNextHanjiChar(text, i);
            if (hanjiMatch) {
              if (syllableCount < maxSyllables) {
                result += hanjiMatch.char;
                syllableCount++;
                i += hanjiMatch.length;
              } else {
                break;
              }
              continue;
            }

            // æª¢æŸ¥æ˜¯å¦ç‚ºæ•¸å­—
            if (/\d/.test(char)) {
              if (syllableCount < maxSyllables) {
                let numberStr = "";
                while (i < text.length && /\d/.test(text[i])) {
                  numberStr += text[i];
                  i++;
                }
                result += numberStr;
                syllableCount++;
              } else {
                break;
              }
              continue;
            }

            // å¦å‰‡è¦–ç‚ºç¾…é¦¬å­—ï¼šæ”¶é›†åˆ°ç©ºæ ¼ã€æ¨™é»æˆ–æ¼¢å­—ç‚ºæ­¢
            let word = "";
            const wordStart = i;
            while (i < text.length) {
              const c = text[i];
              if (c === " " || isPunctuation(c) || getNextHanjiChar(text, i)) {
                break;
              }
              word += c;
              i++;
            }

            if (word.length > 0) {
              const wordSyllables = countSyllables(word);
              if (syllableCount + wordSyllables <= maxSyllables) {
                result += word;
                syllableCount += wordSyllables;
              } else {
                // è¶…ééŸ³ç¯€æ•¸é™åˆ¶ï¼Œä¸åŒ…å«é€™å€‹è©
                i = wordStart;
                break;
              }
            }
          }

          return result.trim() + "...";
        }
      }

      // æˆªå–æ¼¢ç¾…å°æ‡‰æ–‡æœ¬åˆ°æŒ‡å®šéŸ³ç¯€æ•¸
      function truncateMappedText(hanjiText, tailoText, maxSyllables) {
        // åˆ†æå°ç¾…æ–‡æœ¬
        const tailoAnalysis = analyzeTailoText(tailoText);
        const hanjiSegments = smartSegmentHanji(hanjiText, tailoAnalysis);

        let syllableCount = 0;
        let hanjiResult = "";
        let tailoResult = "";
        let prevWasPunctuation = false;

        for (let i = 0; i < tailoAnalysis.length; i++) {
          const item = tailoAnalysis[i];

          if (syllableCount >= maxSyllables) break;

          if (item.isPunctuation) {
            // æ¨™é»ç¬¦è™Ÿä¸ç®—éŸ³ç¯€ï¼Œä½†åŒ…å«åœ¨çµæœä¸­
            hanjiResult += hanjiSegments[i] || item.text;
            tailoResult += item.text;
            prevWasPunctuation = true;
          } else {
            const remainingSyllables = maxSyllables - syllableCount;
            if (item.syllables <= remainingSyllables) {
              // åœ¨è©ä¹‹é–“æ·»åŠ ç©ºæ ¼ï¼ˆå¦‚æœä¸æ˜¯ç¬¬ä¸€å€‹è©ä¸”å‰ä¸€å€‹ä¸æ˜¯æ¨™é»ï¼‰
              if (tailoResult && !prevWasPunctuation) {
                tailoResult += " ";
              }

              hanjiResult += hanjiSegments[i] || "";
              tailoResult += item.text;
              syllableCount += item.syllables;
              prevWasPunctuation = false;
            } else {
              // è¶…ééŸ³ç¯€æ•¸é™åˆ¶ï¼Œä¸åŒ…å«é€™å€‹è©
              break;
            }
          }
        }

        return {
          hanji: hanjiResult.trim() + "...",
          tailo: tailoResult.trim() + "...",
        };
      }

      // éæ¿¾æ–‡ç« 
      let currentSearchQuery = "";
      let currentFilterTag = "";

      // ç²å–ç•¶å¤©çš„æ—¥æœŸå­—ä¸²ï¼ˆYYYY-MM-DDï¼‰
      function getTodayDateString() {
        const today = new Date();
        const year = today.getFullYear();
        const month = String(today.getMonth() + 1).padStart(2, "0");
        const day = String(today.getDate()).padStart(2, "0");
        return `${year}-${month}-${day}`;
      }

      function filterArticles() {
        const searchInput = document.getElementById("articleSearchInput");
        const searchQuery = searchInput
          ? searchInput.value.trim().toLowerCase()
          : "";
        currentSearchQuery = searchQuery;

        let filteredArticles = articles;

        // æ¨™ç±¤éæ¿¾
        if (currentFilterTag) {
          filteredArticles = filteredArticles.filter((article) =>
            article.tags.includes(currentFilterTag)
          );
        }

        // æœå°‹éæ¿¾ï¼ˆæ¨™é¡Œæˆ–æ¨™ç±¤ï¼‰
        if (searchQuery) {
          filteredArticles = filteredArticles.filter((article) => {
            const titleMatch = article.title
              .toLowerCase()
              .includes(searchQuery);
            const tagMatch = article.tags.some((tag) =>
              tag.toLowerCase().includes(searchQuery)
            );
            return titleMatch || tagMatch;
          });
        }

        // åˆ†é›¢ new æ–‡ç« å’Œå…¶ä»–æ–‡ç« 
        const newArticles = filteredArticles.filter(
          (article) => article.new === true
        );
        const otherArticles = filteredArticles.filter(
          (article) => !article.new
        );

        // å° new æ–‡ç« æŒ‰ç…§ id é™åºæ’åˆ—ï¼ˆid è¼ƒå¤§è€…åœ¨å‰ï¼‰
        const sortedNewArticles = newArticles.sort((a, b) => b.id - a.id);

        // ä½¿ç”¨ç•¶å¤©æ—¥æœŸä½œç‚º seed å°å…¶ä»–æ–‡ç« é€²è¡Œéš¨æ©Ÿæ’åº
        const todaySeed = stringToSeed(getTodayDateString());
        const shuffledOtherArticles = shuffleWithSeed(otherArticles, todaySeed);

        // å°‡æ’åºå¾Œçš„ new æ–‡ç« ç½®é ‚
        return [...sortedNewArticles, ...shuffledOtherArticles];
      }

      // é¡¯ç¤ºæ–‡ç« åˆ—è¡¨
      function displayArticleList() {
        const articleList = document.getElementById("articleList");
        const filterInfo = document.getElementById("articleFilterInfo");
        const filterText = document.getElementById("filterText");

        // éæ¿¾æ–‡ç« 
        const filteredArticles = filterArticles();

        // æ›´æ–°éæ¿¾è³‡è¨Šé¡¯ç¤º
        if (currentFilterTag || currentSearchQuery) {
          filterInfo.style.display = "flex";
          let infoText = "";
          if (currentFilterTag) {
            infoText = `æ¨™ç±¤ï¼š${currentFilterTag}`;
          }
          if (currentSearchQuery) {
            if (infoText) infoText += " | ";
            infoText += `æœæ£ï¼š${currentSearchQuery}`;
          }
          filterText.textContent = infoText;
        } else {
          filterInfo.style.display = "none";
        }

        articleList.innerHTML = "";

        if (filteredArticles.length === 0) {
          articleList.innerHTML =
            '<div class="no-articles">æ‰¾ä¸åˆ°ç¬¦åˆæ¢ä»¶çš„æ–‡ç« </div>';
          return;
        }

        filteredArticles.forEach((article) => {
          const articleCard = document.createElement("div");
          articleCard.className = "article-card";
          articleCard.dataset.articleId = article.id;

          const tagsHtml = article.tags
            .map(
              (tag) =>
                `<span class="article-tag clickable-tag" data-tag="${escapeHtml(
                  tag
                )}">${escapeHtml(tag)}</span>`
            )
            .join("");

          // è™•ç†ä¾†æºé€£çµ
          let sourceHtml = "";
          if (article.url && article.url.trim() !== "") {
            sourceHtml = `<span class="article-source">ä¾†æºï¼š<a href="${escapeHtml(
              article.url
            )}" target="_blank" rel="noopener noreferrer">${escapeHtml(
              article.source
            )}</a></span>`;
          } else {
            sourceHtml = `<span class="article-source">ä¾†æºï¼š${escapeHtml(
              article.source
            )}</span>`;
          }

          // è™•ç†é è¦½æ–‡æœ¬ï¼ˆæœ€å¤š 30 å€‹éŸ³ç¯€ï¼‰
          let previewHtml = "";
          if (article.type === "mapped") {
            // æ¼¢ç¾…å°æ‡‰æ–‡æœ¬ï¼šå¾ç¬¬ä¸€è¡Œæˆªå–æœ€å¤š 30 å€‹éŸ³ç¯€
            const hanjiFirstLine = article.hanji.split("\n")[0].trim();
            const tailoFirstLine = article.tailo.split("\n")[0].trim();
            const truncated = truncateMappedText(
              hanjiFirstLine,
              tailoFirstLine,
              30
            );
            previewHtml = `
              <div class="article-preview">
                <div class="preview-hanji">${escapeHtml(truncated.hanji)}</div>
                <div class="preview-tailo">${escapeHtml(truncated.tailo)}</div>
              </div>
            `;
          } else {
            // å–®ä¸€æ–‡æœ¬ï¼šå¾ç¬¬ä¸€è¡Œæˆªå–æœ€å¤š 30 å€‹éŸ³ç¯€
            const contentFirstLine = article.content.split("\n")[0].trim();
            const contentPreview = truncateBySyllables(
              contentFirstLine,
              30,
              false
            );
            previewHtml = `<div class="article-preview">${escapeHtml(
              contentPreview
            )}</div>`;
          }

          // çµ±è¨ˆéŸ³ç¯€æ•¸
          const syllableCount = countArticleSyllables(article);

          // è™•ç† new æ¨™è¨˜
          const newBadge = article.new
            ? '<span class="article-new-badge">new</span>'
            : "";

          articleCard.innerHTML = `
            <div class="article-header">
              <div class="article-title-row">
                <h4 class="article-title">${escapeHtml(article.title)}</h4>
                ${newBadge}
              </div>
              <div class="article-meta">
                ${sourceHtml}
                <span class="article-syllable-count">éŸ³ç¯€æ•¸ï¼š${syllableCount}</span>
              </div>
            </div>
            <div class="article-tags">${tagsHtml}</div>
            ${previewHtml}
            <button class="article-select-btn" data-article-id="${
              article.id
            }">ç·´ç¿’é€™ç¯‡æ–‡ç« </button>
          `;

          articleList.appendChild(articleCard);

          // ç¶å®šé¸æ“‡æŒ‰éˆ•äº‹ä»¶
          const selectBtn = articleCard.querySelector(".article-select-btn");
          selectBtn.addEventListener("click", () => {
            selectArticle(article.id);
          });

          // ç¶å®šæ¨™ç±¤é»æ“Šäº‹ä»¶
          const tagElements = articleCard.querySelectorAll(".clickable-tag");
          tagElements.forEach((tagEl) => {
            tagEl.addEventListener("click", (e) => {
              e.stopPropagation();
              const tag = tagEl.dataset.tag;
              currentFilterTag = tag;
              // æ¸…ç©ºæœå°‹æ¡†
              const searchInput = document.getElementById("articleSearchInput");
              if (searchInput) {
                searchInput.value = "";
              }
              displayArticleList();
            });
          });
        });
      }

      // é¸æ“‡æ–‡ç« 
      function selectArticle(articleId) {
        const article = articles.find((a) => a.id === articleId);
        if (!article) return;

        // æ ¹æ“šæ–‡ç« é¡å‹åˆ‡æ›åˆ°å°æ‡‰çš„æ–‡æœ¬æ¨¡å¼
        if (article.type === "mapped") {
          // æ¼¢ç¾…å°æ‡‰æ–‡æœ¬
          // åˆ‡æ›åˆ°è‡ªè¨‚æ–‡æœ¬æ¨¡å¼
          const customRadio = document.querySelector(
            'input[name="textSource"][value="custom"]'
          );
          if (customRadio) {
            customRadio.checked = true;
          }

          // é¸æ“‡æ¼¢ç¾…å°æ‡‰æ–‡æœ¬é¸é …
          const mappedRadio = document.querySelector(
            'input[name="textType"][value="mapped"]'
          );
          if (mappedRadio) {
            mappedRadio.checked = true;
          }

          // å¡«å…¥æ–‡ç« å…§å®¹
          document.getElementById("hanjiText").value = article.hanji;
          document.getElementById("tailoText").value = article.tailo;

          // æ›´æ–° UI
          toggleTextSource();
          toggleTextType();
          updateSwitcherPosition(".source-options", "textSource");
          updateSwitcherPosition(".text-type-options", "textType");
        } else if (article.type === "single") {
          // å–®ä¸€æ–‡æœ¬
          // åˆ‡æ›åˆ°è‡ªè¨‚æ–‡æœ¬æ¨¡å¼
          const customRadio = document.querySelector(
            'input[name="textSource"][value="custom"]'
          );
          if (customRadio) {
            customRadio.checked = true;
          }

          // é¸æ“‡å–®ä¸€æ–‡æœ¬é¸é …
          const singleRadio = document.querySelector(
            'input[name="textType"][value="single"]'
          );
          if (singleRadio) {
            singleRadio.checked = true;
          }

          // å¡«å…¥æ–‡ç« å…§å®¹
          document.getElementById("singleText").value = article.content;

          // æ›´æ–° UI
          toggleTextSource();
          toggleTextType();
          updateSwitcherPosition(".source-options", "textSource");
          updateSwitcherPosition(".text-type-options", "textType");
        }
      }

      // åˆ‡æ›æ–‡æœ¬é¡å‹æ¨¡å¼
      function toggleTextType() {
        const textType = document.querySelector(
          'input[name="textType"]:checked'
        )?.value;
        const mappedInputs = document.getElementById("mappedInputs");
        const singleInput = document.getElementById("singleInput");
        const modeSelectionSection = document.getElementById(
          "modeSelectionSection"
        );

        if (textType === "mapped") {
          // æ¼¢ç¾…å°æ‡‰æ¨¡å¼ï¼šé¡¯ç¤ºé¸é …
          mappedInputs.style.display = "block";
          singleInput.style.display = "none";
          modeSelectionSection.style.display = "block";
        } else {
          // å–®ä¸€æ–‡æœ¬æ¨¡å¼ï¼šéš±è—ç·´ç¿’æ¨¡å¼
          mappedInputs.style.display = "none";
          singleInput.style.display = "block";
          modeSelectionSection.style.display = "none";
        }
      }

      // ç¾…é¦¬å­—è½‰æ›å‡½æ•¸
      function convertRomanization(targetSystem) {
        const isHanloMapping = isHanloMappingMode();

        if (targetSystem === "poj") {
          // è½‰æ›ç‚ºç™½è©±å­—
          if (isHanloMapping) {
            // æ¼¢ç¾…å°æ‡‰æ¨¡å¼ï¼šè½‰æ›å…©å€‹è¼¸å…¥æ¡†
            const hanjiText = document.getElementById("hanjiText").value;
            const tailoText = document.getElementById("tailoText").value;

            if (hanjiText) {
              document.getElementById("hanjiText").value =
                convertTailoToPOJ(hanjiText);
            }
            if (tailoText) {
              document.getElementById("tailoText").value =
                convertTailoToPOJ(tailoText);
            }
          } else {
            // å–®ä¸€æ–‡æœ¬æ¨¡å¼ï¼šè½‰æ›å–®ä¸€è¼¸å…¥æ¡†
            const singleText = document.getElementById("singleText").value;
            if (singleText) {
              document.getElementById("singleText").value =
                convertTailoToPOJ(singleText);
            }
          }
        } else if (targetSystem === "tailo") {
          // è½‰æ›ç‚ºå°ç¾…
          if (isHanloMapping) {
            // æ¼¢ç¾…å°æ‡‰æ¨¡å¼ï¼šè½‰æ›å…©å€‹è¼¸å…¥æ¡†
            const hanjiText = document.getElementById("hanjiText").value;
            const tailoText = document.getElementById("tailoText").value;

            if (hanjiText) {
              document.getElementById("hanjiText").value =
                convertPOJToTailo(hanjiText);
            }
            if (tailoText) {
              document.getElementById("tailoText").value =
                convertPOJToTailo(tailoText);
            }
          } else {
            // å–®ä¸€æ–‡æœ¬æ¨¡å¼ï¼šè½‰æ›å–®ä¸€è¼¸å…¥æ¡†
            const singleText = document.getElementById("singleText").value;
            if (singleText) {
              document.getElementById("singleText").value =
                convertPOJToTailo(singleText);
            }
          }
        }
      }

      // æ›´æ–°åˆ‡æ›å…ƒä»¶çš„æ»‘å¡Šä½ç½®
      function updateSwitcherPosition(selector, name) {
        const container = document.querySelector(selector);
        if (!container) return;

        const checkedRadio = document.querySelector(
          `input[name="${name}"]:checked`
        );
        if (!checkedRadio) return;

        const radios = document.querySelectorAll(`input[name="${name}"]`);
        const checkedIndex = Array.from(radios).indexOf(checkedRadio);

        // ç§»é™¤æ‰€æœ‰æ»‘å¡Šä½ç½®é¡åˆ¥
        container.classList.remove("switcher-right", "switcher-far-right");

        // å¦‚æœæ˜¯ textSourceï¼Œæ”¯æ´ä¸‰å€‹é¸é …
        if (name === "textSource" && radios.length === 3) {
          if (checkedIndex === 1) {
            container.classList.add("switcher-right");
          } else if (checkedIndex === 2) {
            container.classList.add("switcher-far-right");
          }
        } else {
          // å…¶ä»–é¸é …åªæœ‰å…©å€‹ï¼Œä½¿ç”¨åŸæœ¬çš„é‚è¼¯
          if (checkedIndex === 1) {
            container.classList.add("switcher-right");
          }
        }
      }

      // äº‹ä»¶ç›‘å¬å™¨
      document.querySelectorAll('input[name="textSource"]').forEach((radio) => {
        radio.addEventListener("change", () => {
          toggleTextSource();
          updateSwitcherPosition(".source-options", "textSource");
        });
      });

      document.querySelectorAll('input[name="textType"]').forEach((radio) => {
        radio.addEventListener("change", () => {
          toggleTextType();
          updateSwitcherPosition(".text-type-options", "textType");
        });
      });

      document.querySelectorAll('input[name="inputMode"]').forEach((radio) => {
        radio.addEventListener("change", () => {
          updateSwitcherPosition(".mode-options", "inputMode");
        });
      });

      document
        .querySelectorAll('input[name="romanizationSystemRandom"]')
        .forEach((radio) => {
          radio.addEventListener("change", () => {
            updateSwitcherPosition(
              ".romanization-options",
              "romanizationSystemRandom"
            );
          });
        });

      // ä¿å­˜è¨­å®šåˆ° localStorage
      function saveSettings() {
        const textSource =
          document.querySelector('input[name="textSource"]:checked')?.value ||
          "random";

        // å¦‚æœ textSource æ˜¯ "random"ï¼Œå‰‡ textType å›ºå®šç‚º "mapped"ï¼ˆéš¨æ©Ÿæ¨¡å¼ç¸½æ˜¯ä½¿ç”¨æ¼¢ç¾…å°æ‡‰ï¼‰
        let textType;
        if (textSource === "random") {
          textType = "mapped";
        } else {
          textType =
            document.querySelector('input[name="textType"]:checked')?.value ||
            "mapped";
        }

        const settings = {
          textSource: textSource,
          randomCount: document.getElementById("randomCount")?.value || "5",
          seedInput: document.getElementById("seedInput")?.value || "",
          textType: textType,
          inputMode:
            document.querySelector('input[name="inputMode"]:checked')?.value ||
            "hanji",
          romanizationSystemRandom:
            document.querySelector(
              'input[name="romanizationSystemRandom"]:checked'
            )?.value || "tailo",
          hanjiText: document.getElementById("hanjiText")?.value || "",
          tailoText: document.getElementById("tailoText")?.value || "",
          singleText: document.getElementById("singleText")?.value || "",
        };
        try {
          localStorage.setItem(
            "typingPracticeSettings",
            JSON.stringify(settings)
          );
        } catch (e) {
          console.error("ç„¡æ³•ä¿å­˜è¨­å®šåˆ° localStorage:", e);
        }
      }

      // å¾ localStorage è®€å–ä¸¦æ¢å¾©è¨­å®š
      function loadSettings() {
        try {
          const saved = localStorage.getItem("typingPracticeSettings");
          if (!saved) return;

          const settings = JSON.parse(saved);

          // æ¢å¾©æ–‡æœ¬ä¾†æº
          if (settings.textSource) {
            const textSourceRadio = document.querySelector(
              `input[name="textSource"][value="${settings.textSource}"]`
            );
            if (textSourceRadio) {
              textSourceRadio.checked = true;
            }
          }

          // æ¢å¾©éš¨æ©Ÿä¾‹å¥è¨­å®š
          if (settings.randomCount) {
            const randomCountInput = document.getElementById("randomCount");
            if (randomCountInput) {
              randomCountInput.value = settings.randomCount;
            }
          }
          if (settings.seedInput !== undefined) {
            const seedInput = document.getElementById("seedInput");
            if (seedInput) {
              seedInput.value = settings.seedInput;
            }
          }

          // æ¢å¾©æ–‡æœ¬é¡å‹
          // å¦‚æœ textSource æ˜¯ "random"ï¼Œå‰‡å¼·åˆ¶è¨­ç½®ç‚º "mapped"ï¼ˆéš¨æ©Ÿæ¨¡å¼ç¸½æ˜¯ä½¿ç”¨æ¼¢ç¾…å°æ‡‰ï¼‰
          if (settings.textSource === "random") {
            const textTypeRadio = document.querySelector(
              `input[name="textType"][value="mapped"]`
            );
            if (textTypeRadio) {
              textTypeRadio.checked = true;
            }
          } else if (settings.textType) {
            // åªæœ‰åœ¨è‡ªè¨‚æ–‡æœ¬æ¨¡å¼ä¸‹æ‰æ¢å¾© textType
            const textTypeRadio = document.querySelector(
              `input[name="textType"][value="${settings.textType}"]`
            );
            if (textTypeRadio) {
              textTypeRadio.checked = true;
            }
          }

          // æ¢å¾©ç·´ç¿’æ¨¡å¼
          if (settings.inputMode) {
            const inputModeRadio = document.querySelector(
              `input[name="inputMode"][value="${settings.inputMode}"]`
            );
            if (inputModeRadio) {
              inputModeRadio.checked = true;
            }
          }

          // æ¢å¾©ç¾…é¦¬å­—ç³»çµ±ï¼ˆéš¨æ©Ÿæ¨¡å¼ï¼‰
          if (settings.romanizationSystemRandom) {
            const romanizationRadio = document.querySelector(
              `input[name="romanizationSystemRandom"][value="${settings.romanizationSystemRandom}"]`
            );
            if (romanizationRadio) {
              romanizationRadio.checked = true;
            }
          }

          // æ¢å¾©è‡ªè¨‚æ–‡æœ¬å…§å®¹
          if (settings.hanjiText !== undefined) {
            const hanjiText = document.getElementById("hanjiText");
            if (hanjiText) {
              hanjiText.value = settings.hanjiText;
            }
          }
          if (settings.tailoText !== undefined) {
            const tailoText = document.getElementById("tailoText");
            if (tailoText) {
              tailoText.value = settings.tailoText;
            }
          }
          if (settings.singleText !== undefined) {
            const singleText = document.getElementById("singleText");
            if (singleText) {
              singleText.value = settings.singleText;
            }
          }

          // æ›´æ–° UI ç‹€æ…‹
          toggleTextSource();
          toggleTextType();
          updateSwitcherPosition(".source-options", "textSource");
          updateSwitcherPosition(".text-type-options", "textType");
          updateSwitcherPosition(".mode-options", "inputMode");
          updateSwitcherPosition(
            ".romanization-options",
            "romanizationSystemRandom"
          );
        } catch (e) {
          console.error("ç„¡æ³•å¾ localStorage è®€å–è¨­å®š:", e);
        }
      }

      // åˆå§‹åŒ–ï¼šè¨­ç½®åˆå§‹ç‹€æ…‹
      loadSettings(); // å…ˆè¼‰å…¥ä¿å­˜çš„è¨­å®š
      toggleTextSource();
      toggleTextType();
      updateSwitcherPosition(".source-options", "textSource");
      updateSwitcherPosition(".text-type-options", "textType");
      updateSwitcherPosition(".mode-options", "inputMode");
      updateSwitcherPosition(
        ".romanization-options",
        "romanizationSystemRandom"
      );

      // ç¾…é¦¬å­—è½‰æ›æŒ‰éˆ•
      document
        .getElementById("convertToTailoBtn")
        .addEventListener("click", function () {
          convertRomanization("tailo");
        });

      document
        .getElementById("convertToPOJBtn")
        .addEventListener("click", function () {
          convertRomanization("poj");
        });

      document
        .getElementById("startBtn")
        .addEventListener("click", function () {
          startPractice();
        });

      document
        .getElementById("finishBtn")
        .addEventListener("click", function () {
          finishPractice();
        });

      document
        .getElementById("closeBtn")
        .addEventListener("click", function () {
          closeResult();
        });

      // æ–‡ç« æœå°‹å’Œéæ¿¾åŠŸèƒ½
      const articleSearchInput = document.getElementById("articleSearchInput");
      if (articleSearchInput) {
        articleSearchInput.addEventListener("input", function () {
          displayArticleList();
        });
      }

      const clearFilterBtn = document.getElementById("clearFilterBtn");
      if (clearFilterBtn) {
        clearFilterBtn.addEventListener("click", function () {
          currentFilterTag = "";
          currentSearchQuery = "";
          if (articleSearchInput) {
            articleSearchInput.value = "";
          }
          displayArticleList();
        });
      }

      // åŠ è½½éšæœºä¾‹å¥
      function loadRandomSentences() {
        const count =
          parseInt(document.getElementById("randomCount").value) || 5;
        const seedInput = document.getElementById("seedInput").value;
        const sentences = getRandomSentences(count, seedInput);

        // æ­£è¦åŒ–æ–‡æœ¬ä»¥ç¢ºä¿ Unicode ä¸€è‡´æ€§
        const hanjiLines = sentences.map((s) => normalizeUnicode(s.hanji));
        const tailoLines = sentences.map((s) => normalizeUnicode(s.tailo));

        document.getElementById("hanjiText").value = hanjiLines.join("\n");
        document.getElementById("tailoText").value = tailoLines.join("\n");
      }

      // å¼€å§‹ç»ƒä¹ 
      function startPractice() {
        // ä¿å­˜è¨­å®šåˆ° localStorage
        saveSettings();

        const textSource = document.querySelector(
          'input[name="textSource"]:checked'
        ).value;
        isRandomMode = textSource === "random"; // è¨˜éŒ„æ˜¯å¦ç‚ºéš¨æ©Ÿæ¨¡å¼

        // å¦‚æœæ˜¯éš¨æ©Ÿä¾‹å¥æ¨¡å¼ï¼Œå…ˆè¼‰å…¥ä¾‹å¥
        if (textSource === "random") {
          loadRandomSentences();
        }

        // æª¢æŸ¥æ˜¯å¦ç‚ºæ¼¢ç¾…å°æ‡‰æ¨¡å¼
        const isHanloMapping = isHanloMappingMode();

        let hanjiText, tailoText;

        if (isHanloMapping) {
          // æ¼¢ç¾…å°æ‡‰æ¨¡å¼ï¼šè®€å–å…©å€‹è¼¸å…¥æ¡†
          hanjiText = normalizeUnicode(
            document.getElementById("hanjiText").value.trim()
          );
          tailoText = normalizeUnicode(
            document.getElementById("tailoText").value.trim()
          );

          if (!hanjiText || !tailoText) {
            alert("è«‹è¼¸å…¥ç·´ç¿’æ–‡æœ¬ï¼");
            return;
          }

          // æª¢æŸ¥æ˜¯å¦éœ€è¦è½‰æ›ç‚ºç™½è©±å­—ï¼ˆåªæœ‰éš¨æ©Ÿæ¨¡å¼éœ€è¦ï¼‰
          if (textSource === "random") {
            const romanizationSystem = document.querySelector(
              'input[name="romanizationSystemRandom"]:checked'
            ).value;
            currentRomanizationSystem = romanizationSystem; // è¨˜éŒ„ç•¶å‰ç³»çµ±
            if (romanizationSystem === "poj") {
              // è½‰æ›ç‚ºç™½è©±å­—ä¸¦æ­£è¦åŒ–
              hanjiText = normalizeUnicode(convertTailoToPOJ(hanjiText));
              tailoText = normalizeUnicode(convertTailoToPOJ(tailoText));
            }
          } else {
            // è‡ªè¨‚æ–‡æœ¬æ¨¡å¼ï¼šä¸åœ¨æ­¤è™•è½‰æ›ï¼Œä½¿ç”¨è€…è‡ªè¡Œä½¿ç”¨è½‰æ›æŒ‰éˆ•
            currentRomanizationSystem = "tailo";
          }

          inputMode = document.querySelector(
            'input[name="inputMode"]:checked'
          ).value;
        } else {
          // å–®ä¸€æ–‡æœ¬æ¨¡å¼ï¼šåªè®€å–ä¸€å€‹è¼¸å…¥æ¡†
          const singleText = normalizeUnicode(
            document.getElementById("singleText").value.trim()
          );

          if (!singleText) {
            alert("è«‹è¼¸å…¥ç·´ç¿’æ–‡æœ¬ï¼");
            return;
          }

          // å–®ä¸€æ–‡æœ¬æ¨¡å¼ä¸‹ï¼Œå…©å€‹æ–‡æœ¬ç›¸åŒï¼ˆä¸éœ€è¦rubyå°æ‡‰ï¼‰
          hanjiText = singleText;
          tailoText = singleText;

          // å–®ä¸€æ–‡æœ¬æ¨¡å¼ä¸åšç¾…é¦¬å­—è½‰æ›ï¼Œä½¿ç”¨å°ç¾…ç³»çµ±
          currentRomanizationSystem = "tailo";

          // å–®ä¸€æ–‡æœ¬æ¨¡å¼é è¨­ç‚ºæ¼¢å­—è¼¸å…¥æ¨¡å¼
          inputMode = "hanji";
        }

        hanjiParagraphs = hanjiText
          .split("\n")
          .filter((p) => p.trim().length > 0);
        tailoParagraphs = tailoText
          .split("\n")
          .filter((p) => p.trim().length > 0);

        // æª¢æ¸¬æ˜¯å¦ç‚ºå–®ä¸€æ–‡æœ¬æ¨¡å¼
        isSingleTextMode = hanjiParagraphs[0] === tailoParagraphs[0];

        if (hanjiParagraphs.length !== tailoParagraphs.length) {
          alert("æ¼¢å­—å’Œå°ç¾…çš„æ®µè½æ•¸ä¸ä¸€è‡´ï¼Œè«‹æª¢æŸ¥ï¼");
          return;
        }

        // æ ¹æ®æ¨¡å¼è®¾ç½®è¦è¾“å…¥çš„æ–‡æœ¬
        if (inputMode === "hanji") {
          if (isSingleTextMode) {
            // å–®ä¸€æ–‡æœ¬æ¨¡å¼ï¼šä¿ç•™æ¨™é»å’Œç©ºæ ¼
            paragraphs = hanjiParagraphs;
          } else {
            // æ¼¢ç¾…å°æ‡‰æ¨¡å¼ï¼šç§»é™¤æ‰€æœ‰ç©ºæ ¼
            paragraphs = hanjiParagraphs.map((h) => h.replace(/\s+/g, ""));
          }
        } else {
          // è¾“å…¥å°ç½—æ¨¡å¼ï¼šä¿ç•™åŸå§‹ç©ºæ ¼
          paragraphs = tailoParagraphs;
        }

        // æš«æ™‚è¨­ç‚º0ï¼Œå¾…DOMç”Ÿæˆå¾Œå†è¨ˆç®—éŸ³ç¯€æ•¸
        stats.totalChars = 0;

        document.getElementById("setupArea").style.display = "none";
        document.getElementById("statsBar").classList.add("active");
        document.getElementById("practiceArea").classList.add("active");

        createTypingSections();
        resetStats();

        const prepInput = document.getElementById("prepInput");
        if (prepInput) {
          prepInput.value = "";
          prepInput.disabled = false;
          prepInput.removeEventListener("keydown", handlePrepKeyDown);
          prepInput.removeEventListener(
            "compositionstart",
            handleCompositionStart
          );
          prepInput.removeEventListener("compositionend", handleCompositionEnd);
          prepInput.addEventListener("keydown", handlePrepKeyDown);
          prepInput.addEventListener(
            "compositionstart",
            handleCompositionStart
          );
          prepInput.addEventListener("compositionend", handleCompositionEnd);
          // ç¦æ­¢è²¼ä¸Šï¼ˆé™¤éŒ¯æ¨¡å¼ä¸‹å¯è§£é™¤ï¼‰
          prepInput.addEventListener("paste", (e) => {
            if (!allowPaste) {
              e.preventDefault();
            }
          });
          prepInput.focus();
        }
      }

      // åˆ›å»ºæ‰“å­—åŒºåŸŸ
      function createTypingSections() {
        const container = document.getElementById("typingSections");
        container.innerHTML = "";

        paragraphs.forEach((paragraph, index) => {
          const section = document.createElement("div");
          section.className = "typing-section";

          const refHTML = createRubyText(index);

          section.innerHTML =
            '<div class="reference-text" id="refText' +
            index +
            '">' +
            refHTML +
            "</div>" +
            '<div class="input-area">' +
            '<textarea class="typing-input" id="input' +
            index +
            '" data-index="' +
            index +
            '" ' +
            'autocomplete="off" spellcheck="false" rows="1"></textarea>' +
            "</div>";

          container.appendChild(section);

          const input = section.querySelector(".typing-input");
          // åˆå§‹åŒ– textarea é«˜åº¦
          autoResizeTextarea(input);
          input.addEventListener("input", handleInput);
          input.addEventListener("keydown", handleKeyDown);
          input.addEventListener("compositionstart", handleCompositionStart);
          input.addEventListener("compositionend", (e) => {
            handleCompositionEnd(e);
            // åœ¨è¼¸å…¥æ³•çµæŸæ™‚ä¹Ÿèª¿æ•´é«˜åº¦
            autoResizeTextarea(input);
          });
          // ç¦æ­¢è²¼ä¸Šï¼ˆé™¤éŒ¯æ¨¡å¼ä¸‹å¯è§£é™¤ï¼‰
          input.addEventListener("paste", (e) => {
            if (!allowPaste) {
              e.preventDefault();
            }
          });
        });

        // è¨ˆç®—ç¸½éŸ³ç¯€æ•¸ï¼ˆå¾æ‰€æœ‰æ®µè½çš„ char-mark å…ƒç´ è¨ˆç®—ï¼‰
        stats.totalChars = 0;
        container.querySelectorAll(".reference-text").forEach((refText) => {
          stats.totalChars += countSyllablesFromDOM(refText);
        });
      }

      // åˆ›å»ºRubyæ ‡æ³¨
      function createRubyText(paragraphIndex) {
        const hanjiText = hanjiParagraphs[paragraphIndex];
        const tailoText = tailoParagraphs[paragraphIndex];

        // æª¢æŸ¥æ˜¯å¦ç‚ºå–®ä¸€æ–‡æœ¬æ¨¡å¼ï¼ˆå…©å€‹æ–‡æœ¬ç›¸åŒï¼‰
        const isSingleTextMode = hanjiText === tailoText;

        if (isSingleTextMode) {
          // å–®ä¸€æ–‡æœ¬æ¨¡å¼ï¼šä¸é¡¯ç¤ºrubyï¼Œä½†æŒ‰éŸ³ç¯€æ‹†åˆ†ä»¥ä¾¿åˆ¤å®š
          return createSingleTextMarkup(hanjiText);
        }

        const tailoAnalysis = analyzeTailoText(tailoText);
        const hanjiSegments = smartSegmentHanji(hanjiText, tailoAnalysis);

        if (inputMode === "hanji") {
          // æ¼¢å­—æ¨¡å¼ï¼šæ˜¾ç¤ºæ±‰å­—ï¼Œæ ‡æ³¨å°ç½—
          // ä½¿ç”¨é€å­—ç¬¦æƒæä¾†ä¿ç•™åŸå§‹æ–‡æœ¬çš„ç©ºæ ¼
          let html = "";
          let wordIdx = 0;
          let i = 0;
          let lastRuby = ""; // è¿½è¹¤ä¸Šä¸€å€‹ ruby å…ƒç´ çš„ HTML

          while (i < tailoText.length && wordIdx < tailoAnalysis.length) {
            const char = tailoText[i];

            // è™•ç†ç©ºæ ¼
            if (char === " ") {
              html += " ";
              lastRuby = ""; // ç©ºæ ¼å¾Œé‡ç½®
              i++;
            } else if (isPunctuation(char)) {
              // æª¢æŸ¥é€™å€‹æ¨™é»æ˜¯å¦å°æ‡‰ tailoAnalysis ä¸­çš„æ¨™é»
              if (
                wordIdx < tailoAnalysis.length &&
                tailoAnalysis[wordIdx].isPunctuation
              ) {
                const item = tailoAnalysis[wordIdx];
                const hanji = hanjiSegments[wordIdx] || "";

                // ç‚ºæ¨™é»ç¬¦è™Ÿæ·»åŠ ç‰¹æ®Š class ä»¥ä¾¿ CSS è™•ç†é¿é ­é»
                const punctuationClass = item.isPunctuation
                  ? " punctuation-mark"
                  : "";

                // å¦‚æœæœ‰å‰ä¸€å€‹å­—ç¬¦ï¼Œå°‡å®ƒå’Œæ¨™é»ç¬¦è™ŸåŒ…åœ¨ä¸€èµ·ä»¥é˜²æ­¢åˆ†é–‹
                if (lastRuby) {
                  // ç§»é™¤ä¸Šä¸€å€‹ ruby å…ƒç´ ï¼Œå°‡å®ƒå’Œæ¨™é»ç¬¦è™ŸåŒ…åœ¨ä¸€èµ·
                  html = html.slice(0, -lastRuby.length);
                  html +=
                    '<span class="kinsoku-group" style="white-space: nowrap; display: inline-block;">';
                  html += lastRuby;
                  html += '<span class="kinsoku-space">\u2060</span>';
                  html += '<ruby class="char-mark' + punctuationClass + '">';
                  html += escapeHtml(hanji);
                  html += "<rt>" + escapeHtml(item.text) + "</rt>";
                  html += "</ruby>";
                  html += "</span>";
                } else {
                  // æ²’æœ‰å‰ä¸€å€‹å­—ç¬¦ï¼Œåªæ·»åŠ æ¨™é»ç¬¦è™Ÿ
                  html += '<span class="kinsoku-space">\u2060</span>';
                  html += '<ruby class="char-mark' + punctuationClass + '">';
                  html += escapeHtml(hanji);
                  html += "<rt>" + escapeHtml(item.text) + "</rt>";
                  html += "</ruby>";
                }
                lastRuby = ""; // æ¨™é»ç¬¦è™Ÿå¾Œé‡ç½®

                i += item.text.length;
                wordIdx++;
              } else {
                // ä¸åœ¨ tailoAnalysis ä¸­ï¼Œç›´æ¥è¼¸å‡º
                html += char;
                lastRuby = "";
                i++;
              }
            } else {
              // è™•ç†è©
              const item = tailoAnalysis[wordIdx];
              const tailo = item.text;
              const hanji = hanjiSegments[wordIdx] || "";

              // æª¢æŸ¥ç•¶å‰ä½ç½®æ˜¯å¦åŒ¹é…é€™å€‹è©
              const remaining = tailoText.substring(i);
              if (remaining.startsWith(tailo)) {
                lastRuby = '<ruby class="char-mark">';
                lastRuby += escapeHtml(hanji);
                lastRuby += "<rt>" + escapeHtml(tailo) + "</rt>";
                lastRuby += "</ruby>";
                html += lastRuby;

                i += tailo.length;
                wordIdx++;
              } else {
                // ä¸åŒ¹é…ï¼Œè·³éç•¶å‰å­—ç¬¦
                html += char;
                lastRuby = "";
                i++;
              }
            }
          }

          // è¼¸å‡ºå‰©é¤˜å­—ç¬¦
          while (i < tailoText.length) {
            html += tailoText[i];
            i++;
          }

          return html;
        } else {
          // å°ç½—æ¨¡å¼ï¼šé€å­—ç¬¦æ‰«æåŸå§‹æ–‡æœ¬ï¼ŒåŒ¹é…åˆ†æç»“æœ
          let html = "";
          let wordIdx = 0;
          let i = 0;
          let lastRuby = ""; // è¿½è¹¤ä¸Šä¸€å€‹ ruby å…ƒç´ çš„ HTML

          while (i < tailoText.length && wordIdx < tailoAnalysis.length) {
            const char = tailoText[i];

            if (char === " ") {
              // ç©ºæ ¼ç›´æ¥è¾“å‡º
              html += " ";
              lastRuby = ""; // ç©ºæ ¼å¾Œé‡ç½®
              i++;
            } else {
              const item = tailoAnalysis[wordIdx];
              const tailo = item.text;
              const hanji = hanjiSegments[wordIdx] || "";

              // æ£€æŸ¥å½“å‰ä½ç½®æ˜¯å¦åŒ¹é…è¿™ä¸ªè¯
              const remaining = tailoText.substring(i);
              if (remaining.startsWith(tailo)) {
                // ç‚ºæ¨™é»ç¬¦è™Ÿæ·»åŠ ç‰¹æ®Š class ä»¥ä¾¿ CSS è™•ç†é¿é ­é»
                const punctuationClass = item.isPunctuation
                  ? " punctuation-mark"
                  : "";

                // å¦‚æœæœ‰å‰ä¸€å€‹å­—ç¬¦ï¼Œå°‡å®ƒå’Œæ¨™é»ç¬¦è™ŸåŒ…åœ¨ä¸€èµ·ä»¥é˜²æ­¢åˆ†é–‹
                if (item.isPunctuation && lastRuby) {
                  // ç§»é™¤ä¸Šä¸€å€‹ ruby å…ƒç´ ï¼Œå°‡å®ƒå’Œæ¨™é»ç¬¦è™ŸåŒ…åœ¨ä¸€èµ·
                  html = html.slice(0, -lastRuby.length);
                  html +=
                    '<span class="kinsoku-group" style="white-space: nowrap; display: inline-block;">';
                  html += lastRuby;
                  html += '<span class="kinsoku-space">\u2060</span>';
                  html += '<ruby class="char-mark' + punctuationClass + '">';
                  html += escapeHtml(tailo);
                  html += "<rt>" + escapeHtml(hanji) + "</rt>";
                  html += "</ruby>";
                  html += "</span>";
                  lastRuby = ""; // æ¨™é»ç¬¦è™Ÿå¾Œé‡ç½®
                } else {
                  // æ²’æœ‰å‰ä¸€å€‹å­—ç¬¦æˆ–æ˜¯éæ¨™é»ç¬¦è™Ÿï¼Œæ­£å¸¸æ·»åŠ 
                  if (item.isPunctuation) {
                    html += '<span class="kinsoku-space">\u2060</span>';
                  }
                  lastRuby = '<ruby class="char-mark' + punctuationClass + '">';
                  lastRuby += escapeHtml(tailo);
                  lastRuby += "<rt>" + escapeHtml(hanji) + "</rt>";
                  lastRuby += "</ruby>";
                  html += lastRuby;
                }

                i += tailo.length;
                wordIdx++;
              } else {
                // ä¸åŒ¹é…ï¼Œå¯èƒ½æ˜¯æ ‡ç‚¹ç´§è·Ÿï¼Œè·³è¿‡å½“å‰å­—ç¬¦
                html += char;
                lastRuby = "";
                i++;
              }
            }
          }

          // è¾“å‡ºå‰©ä½™å­—ç¬¦
          while (i < tailoText.length) {
            html += tailoText[i];
            i++;
          }

          return html;
        }
      }

      // å‰µå»ºå–®ä¸€æ–‡æœ¬æ¨¡å¼çš„æ¨™è¨˜ï¼ˆæŒ‰éŸ³ç¯€æ‹†åˆ†ï¼Œä¸é¡¯ç¤ºrubyï¼‰
      function createSingleTextMarkup(text) {
        let html = "";
        let i = 0;
        let lastCharMark = ""; // è¿½è¹¤ä¸Šä¸€å€‹å­—ç¬¦çš„ HTML

        while (i < text.length) {
          const char = text[i];

          // è™•ç†ç©ºæ ¼ï¼šç›´æ¥è¼¸å‡ºï¼Œä¸åŒ…åœ¨ char-mark ä¸­
          if (char === " ") {
            html += " ";
            lastCharMark = ""; // ç©ºæ ¼å¾Œé‡ç½®
            i++;
            continue;
          }

          // è™•ç†æ¨™é»ç¬¦è™Ÿï¼šåŒ…åœ¨ char-mark ä¸­ï¼Œä½†æ¨™è¨˜ç‚ºæ¨™é»
          if (isPunctuation(char)) {
            // å¦‚æœæœ‰å‰ä¸€å€‹å­—ç¬¦ï¼Œå°‡å®ƒå’Œæ¨™é»ç¬¦è™ŸåŒ…åœ¨ä¸€èµ·ä»¥é˜²æ­¢åˆ†é–‹
            if (lastCharMark) {
              // ç§»é™¤ä¸Šä¸€å€‹å­—ç¬¦çš„çµå°¾æ¨™ç±¤ï¼Œå°‡å®ƒå’Œæ¨™é»ç¬¦è™ŸåŒ…åœ¨ä¸€èµ·
              html = html.slice(0, -lastCharMark.length);
              html +=
                '<span class="kinsoku-group" style="white-space: nowrap; display: inline-block;">';
              html += lastCharMark;
              html += '<span class="kinsoku-space">\u2060</span>';
              html +=
                '<span class="char-mark punctuation-mark">' +
                escapeHtml(char) +
                "</span>";
              html += "</span>";
            } else {
              // æ²’æœ‰å‰ä¸€å€‹å­—ç¬¦ï¼Œåªæ·»åŠ æ¨™é»ç¬¦è™Ÿï¼ˆé€™ç¨®æƒ…æ³è¼ƒå°‘è¦‹ï¼‰
              html += '<span class="kinsoku-space">\u2060</span>';
              html +=
                '<span class="char-mark punctuation-mark">' +
                escapeHtml(char) +
                "</span>";
            }
            lastCharMark = ""; // æ¨™é»ç¬¦è™Ÿå¾Œé‡ç½®
            i++;
            continue;
          }

          // æª¢æŸ¥æ˜¯å¦ç‚ºæ¼¢å­—ï¼ˆåŒ…æ‹¬ä»£ç†å°ï¼‰
          const hanjiMatch = getNextHanjiChar(text, i);
          if (hanjiMatch) {
            // æ˜¯æ¼¢å­—ï¼šå–®å€‹æ¼¢å­—ä¸€å€‹ char-mark
            lastCharMark =
              '<span class="char-mark">' +
              escapeHtml(hanjiMatch.char) +
              "</span>";
            html += lastCharMark;
            i += hanjiMatch.length;
            continue;
          }

          // æª¢æŸ¥æ˜¯å¦ç‚ºæ•¸å­—
          if (/\d/.test(char)) {
            // æ”¶é›†é€£çºŒæ•¸å­—
            let numberStr = "";
            while (i < text.length && /\d/.test(text[i])) {
              numberStr += text[i];
              i++;
            }
            lastCharMark =
              '<span class="char-mark">' + escapeHtml(numberStr) + "</span>";
            html += lastCharMark;
            continue;
          }

          // å¦å‰‡è¦–ç‚ºç¾…é¦¬å­—ï¼šæ”¶é›†åˆ°ç©ºæ ¼ã€æ¨™é»æˆ–æ¼¢å­—ç‚ºæ­¢
          let word = "";
          while (i < text.length) {
            const c = text[i];

            // é‡åˆ°ç©ºæ ¼ã€æ¨™é»æˆ–æ¼¢å­—å°±åœæ­¢
            if (c === " " || isPunctuation(c) || getNextHanjiChar(text, i)) {
              break;
            }

            word += c;
            i++;
          }

          // å°‡ç¾…é¦¬å­—è©æŒ‰éŸ³ç¯€æ‹†åˆ†
          if (word.length > 0) {
            const romanizationHTML = createRomanizationMarkup(word);
            html += romanizationHTML;
            // æå–æœ€å¾Œä¸€å€‹å­—ç¬¦æ¨™è¨˜ä½œç‚º lastCharMark
            // ç°¡å–®è™•ç†ï¼šå¦‚æœåªæœ‰ä¸€å€‹éŸ³ç¯€ï¼Œå°±è¨˜éŒ„å®ƒ
            const matches = romanizationHTML.match(
              /<span class="char-mark">([^<]+)<\/span>/g
            );
            if (matches && matches.length > 0) {
              lastCharMark = matches[matches.length - 1];
            } else {
              lastCharMark = "";
            }
          }
        }

        return html;
      }

      // ç²å–ä¸‹ä¸€å€‹æ¼¢å­—å­—ç¬¦ï¼ˆè™•ç†ä»£ç†å°ï¼‰
      function getNextHanjiChar(text, index) {
        if (index >= text.length) return null;

        const char = text[index];
        const code = char.charCodeAt(0);

        // æª¢æŸ¥æ˜¯å¦ç‚ºé«˜ä»£ç†é …ï¼ˆU+D800-U+DBFFï¼‰
        if (code >= 0xd800 && code <= 0xdbff) {
          // æª¢æŸ¥ä¸‹ä¸€å€‹å­—ç¬¦æ˜¯å¦ç‚ºä½ä»£ç†é …
          if (index + 1 < text.length) {
            const nextCode = text.charCodeAt(index + 1);
            if (nextCode >= 0xdc00 && nextCode <= 0xdfff) {
              // é€™æ˜¯ä¸€å€‹ä»£ç†å°ï¼ˆExt-B ä»¥å¾Œçš„æ¼¢å­—ï¼‰
              const surrogatePair = char + text[index + 1];
              if (isHanjiChar(surrogatePair)) {
                return { char: surrogatePair, length: 2 };
              }
            }
          }
        }

        // æª¢æŸ¥æ˜¯å¦ç‚ºæ™®é€š BMP ç¯„åœçš„æ¼¢å­—
        if (isHanjiChar(char)) {
          return { char: char, length: 1 };
        }

        return null;
      }

      // åˆ¤æ–·æ˜¯å¦ç‚ºæ¼¢å­—
      function isHanjiChar(char) {
        // ä½¿ç”¨æ­£å‰‡è¡¨é”å¼åŒ¹é… CJK çµ±ä¸€æ¼¢å­—å„å€‹å€å¡Š
        // åŒ…æ‹¬åŸºæœ¬å€ã€æ“´å±•A-Gã€ç›¸å®¹æ¼¢å­—ç­‰
        return /[\u4E00-\u9FFF\u3400-\u4DBF\u{20000}-\u{2A6DF}\u{2A700}-\u{2B73F}\u{2B740}-\u{2B81F}\u{2B820}-\u{2CEAF}\u{2CEB0}-\u{2EBEF}\u{30000}-\u{3134F}\uF900-\uFAFF\u{2F800}-\u{2FA1F}]/u.test(
          char
        );
      }

      // å°‡ç¾…é¦¬å­—è©æŒ‰éŸ³ç¯€æ‹†åˆ†ä¸¦æ¨™è¨˜
      function createRomanizationMarkup(word) {
        // å°‡æ•´å€‹è©ï¼ˆåŒ…å«é€£å­—ç¬¦ï¼‰ä½œç‚ºä¸€å€‹ char-mark
        // é€™æ¨£é€£å­—ç¬¦è™Ÿå°±æœƒåŒ…å«åœ¨åƒè€ƒæ–‡æœ¬ä¸­
        return '<span class="char-mark">' + escapeHtml(word) + "</span>";
      }

      // åˆ†æå°ç½—æ–‡æœ¬
      function analyzeTailoText(tailoText) {
        // å…ˆå°†æ ‡ç‚¹ç¬¦å·ä¸è¯åˆ†ç¦»
        const normalized = normalizeTailoText(tailoText);
        const words = normalized.split(/\s+/).filter((w) => w.length > 0);
        const analysis = [];

        for (const word of words) {
          if (isPunctuation(word)) {
            analysis.push({
              text: word,
              syllables: 1,
              isPunctuation: true,
            });
          } else if (/^\d+$/.test(word)) {
            // çº¯æ•°å­—ï¼ŒéŸ³èŠ‚æ•°ä¸º1ï¼ˆä½œä¸ºä¸€ä¸ªæ•´ä½“ï¼‰
            analysis.push({
              text: word,
              syllables: 1,
              isPunctuation: false,
            });
          } else {
            const syllables = countSyllables(word);
            analysis.push({
              text: word,
              syllables: syllables,
              isPunctuation: false,
            });
          }
        }

        return analysis;
      }

      // è§„èŒƒåŒ–å°ç½—æ–‡æœ¬ï¼šå°†æ ‡ç‚¹ç¬¦å·ä¸è¯åˆ†ç¦»
      function normalizeTailoText(text) {
        // åœ¨æ ‡ç‚¹ç¬¦å·å‰åæ·»åŠ ç©ºæ ¼
        const punctMarks = "ï¼Œã€‚ã€ï¼ï¼Ÿï¼šï¼›,.!?:;";
        let result = text;

        for (const mark of punctMarks) {
          // åœ¨æ ‡ç‚¹å‰åéƒ½åŠ ç©ºæ ¼ï¼Œé¿å…é‡å¤ç©ºæ ¼
          const regex = new RegExp("\\s*\\" + mark + "\\s*", "g");
          result = result.replace(regex, " " + mark + " ");
        }

        // å¤„ç†å„ç§å¼•å·
        result = result.replace(/\s*"\s*/g, ' " '); // æ™®é€šåŒå¼•å·
        result = result.replace(/\s*\u201C\s*/g, " \u201C "); // å·¦åŒå¼•å· "
        result = result.replace(/\s*\u201D\s*/g, " \u201D "); // å³åŒå¼•å· "
        result = result.replace(/\s*\'\s*/g, " ' "); // æ™®é€šå•å¼•å·
        result = result.replace(/\s*\u2018\s*/g, " \u2018 "); // å·¦å•å¼•å· '
        result = result.replace(/\s*\u2019\s*/g, " \u2019 "); // å³å•å¼•å· '

        // æ¸…ç†å¤šä½™ç©ºæ ¼
        result = result.replace(/\s+/g, " ").trim();

        return result;
      }

      // è®¡ç®—éŸ³èŠ‚æ•°
      function countSyllables(word) {
        const cleaned = word.replace(/--/g, "-");
        const parts = cleaned.split("-");
        const syllables = parts.filter((p) => p.length > 0);
        return syllables.length;
      }

      // åˆ¤æ–­æ˜¯å¦ä¸ºæ ‡ç‚¹
      function isPunctuation(text) {
        const marks = "ï¼Œã€‚ã€ï¼ï¼Ÿã€Œã€ï¼šï¼›ï¼ˆï¼‰,.!?:;''ã€ã€ã€ã€‘ã€Šã€‹ã€ˆã€‰â€œâ€â€˜â€™";
        return marks.includes(text);
      }

      // åˆ¤æ–­ä¸¤ä¸ªæ ‡ç‚¹æ˜¯å¦å¯¹åº”ï¼ˆä¾‹å¦‚ä¸­è‹±æ–‡å¼•å·ï¼‰
      function isPunctuationMatch(hanjiChar, tailoChar) {
        // å®Œå…¨ç›¸åŒ
        if (hanjiChar === tailoChar) return true;

        // ä¸­è‹±æ–‡æ ‡ç‚¹å¯¹åº”
        const punctPairs = {
          "ã€Œ": "â€œ", // ã€Œ â†’ "
          "ã€": "â€", // ã€ â†’ "
          "ã€": "â€˜", // ã€ â†’ '
          "ã€": "â€™", // ã€ â†’ '
          "ï¼Œ": ",",
          "ã€‚": ".",
          "ï¼": "!",
          "ï¼Ÿ": "?",
          "ï¼š": ":",
          "ï¼›": ";",
          "ï¼ˆ": "(",
          "ï¼‰": ")",
        };

        return punctPairs[hanjiChar] === tailoChar;
      }

      // åˆ¤æ–­å­—ç¬¦æ˜¯å¦ä¸ºå°ç½—æ‹¼éŸ³å­—ç¬¦ï¼ˆåŒ…å«å­—æ¯ã€è¿å­—ç¬¦ã€å£°è°ƒç¬¦å·ï¼‰
      function isTailoChar(char) {
        // å¦‚æœå­—ç´ åŒ…å«çµ„åˆå­—ç¬¦ï¼Œæª¢æŸ¥ç¬¬ä¸€å€‹å­—ç¬¦ï¼ˆåŸºå­—ç¬¦ï¼‰
        const baseChar = char[0];

        // åŸºæœ¬æ‹‰ä¸å­—æ¯
        if (/[a-zA-Z]/.test(baseChar)) return true;
        // è¿å­—ç¬¦
        if (baseChar === "-") return true;
        // å°ç½—å£°è°ƒç¬¦å·çš„UnicodeèŒƒå›´
        const code = baseChar.charCodeAt(0);
        // æ‹‰ä¸æ–‡è¡¥å……-1: Ã Ã¡Ã¢Ã£Ã¤Ã¥Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã²Ã³Ã´ÃµÃ¶Ã¹ÃºÃ»Ã¼ç­‰
        if (code >= 0x00c0 && code <= 0x00ff) return true;
        // æ‹‰ä¸æ–‡æ‰©å±•A: ÄÄƒÄ…Ä‡Ä‰Ä‹ÄÄÄ‘Ä“Ä•Ä—Ä™Ä›ç­‰
        if (code >= 0x0100 && code <= 0x017f) return true;
        // æ‹‰ä¸æ–‡æ‰©å±•B: Æ¡Æ°ç­‰
        if (code >= 0x0180 && code <= 0x024f) return true;
        // æ‹‰ä¸æ–‡æ‰©å±•é™„åŠ : á¹á¹…á¹‡á¹‰ç­‰
        if (code >= 0x1e00 && code <= 0x1eff) return true;
        return false;
      }

      // å°‡å­—ç¬¦ä¸²æ­£ç¢ºåˆ†å‰²ç‚ºå­—ç´ ï¼ˆgrapheme clustersï¼‰
      // é€™æ¨£å¯ä»¥æ­£ç¢ºè™•ç†çµ„åˆå­—ç¬¦ï¼Œå¦‚ aÌ (a + çµ„åˆè²èª¿ç¬¦è™Ÿ)
      function splitIntoGraphemes(text) {
        // \P{M} åŒ¹é…éæ¨™è¨˜å­—ç¬¦ï¼ˆåŸºå­—ç¬¦ï¼‰
        // \p{M}* åŒ¹é…é›¶å€‹æˆ–å¤šå€‹æ¨™è¨˜å­—ç¬¦ï¼ˆçµ„åˆå­—ç¬¦ï¼‰
        return text.match(/\P{M}\p{M}*/gu) || [];
      }

      // ä»æ¼¢å­—æ–‡æœ¬ä¸­æå–ç‰¹æ®Šéƒ¨åˆ†ï¼ˆæ•°å­—å’Œå°ç½—æ··å†™ï¼‰
      function extractSpecialSegments(hanjiText) {
        const chars = splitIntoGraphemes(hanjiText);
        const segments = [];
        let i = 0;

        while (i < chars.length) {
          const char = chars[i];

          // æ£€æŸ¥æ˜¯å¦ä¸ºæ•°å­—
          if (/\d/.test(char)) {
            let numStr = char;
            const startPos = i;
            i++;
            // æ”¶é›†è¿ç»­çš„æ•°å­—
            while (i < chars.length && /\d/.test(chars[i])) {
              numStr += chars[i];
              i++;
            }
            segments.push({
              type: "number",
              text: numStr,
              start: startPos,
              end: i,
            });
          }
          // æ£€æŸ¥æ˜¯å¦ä¸ºå°ç½—æ‹¼éŸ³å­—ç¬¦
          else if (isTailoChar(char)) {
            let tailoStr = char;
            const startPos = i;
            i++;
            // æ”¶é›†è¿ç»­çš„å°ç½—å­—ç¬¦ï¼ˆåŒ…æ‹¬é€£å­—ç¬¦ï¼‰
            while (
              i < chars.length &&
              (isTailoChar(chars[i]) || chars[i] === "-")
            ) {
              tailoStr += chars[i];
              i++;
            }
            segments.push({
              type: "tailo",
              text: tailoStr,
              start: startPos,
              end: i,
            });
          } else {
            i++;
          }
        }

        return segments;
      }

      // æ™ºèƒ½åˆ‡åˆ†æ±‰å­—
      function smartSegmentHanji(hanjiText, tailoAnalysis) {
        hanjiText = hanjiText.replace(/\s+/g, "");

        // æå–ç‰¹æ®Šæ®µè½ï¼ˆæ•°å­—å’Œå°ç½—æ··å†™ï¼‰
        const specialSegments = extractSpecialSegments(hanjiText);

        const chars = splitIntoGraphemes(hanjiText);
        const segments = [];
        let charIndex = 0;
        let tailoIndex = 0;

        while (tailoIndex < tailoAnalysis.length) {
          const item = tailoAnalysis[tailoIndex];

          if (item.isPunctuation) {
            if (charIndex < chars.length) {
              const hanjiChar = chars[charIndex];
              // æ£€æŸ¥æ˜¯å¦ä¸ºå¯¹åº”çš„æ ‡ç‚¹ï¼ˆæ”¯æŒä¸­è‹±æ–‡å¼•å·ç­‰ï¼‰
              if (
                isPunctuation(hanjiChar) ||
                isPunctuationMatch(hanjiChar, item.text)
              ) {
                segments.push(hanjiChar);
                charIndex++;
              } else {
                segments.push(item.text);
              }
            } else {
              segments.push(item.text);
            }
            tailoIndex++;
          } else {
            // æ£€æŸ¥å½“å‰ä½ç½®æ˜¯å¦æœ‰ç‰¹æ®Šæ®µè½ï¼ˆæ•°å­—æˆ–å°ç½—æ··å†™ï¼‰
            const specialAtPos = specialSegments.find(
              (s) => s.start === charIndex
            );

            if (specialAtPos) {
              // å˜—è©¦é€£çºŒåŒ¹é…å¤šå€‹ç¾…é¦¬å­—è©ï¼ˆç§»é™¤ç©ºæ ¼å¾Œï¼‰
              let combinedText = "";
              let matchedWords = [];
              let matched = false;

              for (
                let i = tailoIndex;
                i < tailoAnalysis.length && !tailoAnalysis[i].isPunctuation;
                i++
              ) {
                combinedText += tailoAnalysis[i].text.replace(/\s+/g, "");
                matchedWords.push(tailoAnalysis[i].text);

                // æª¢æŸ¥æ˜¯å¦åŒ¹é…
                if (combinedText === specialAtPos.text) {
                  // ç‚ºæ¯å€‹è©ç”Ÿæˆç¨ç«‹çš„ segment
                  for (const word of matchedWords) {
                    segments.push(word);
                  }
                  charIndex = specialAtPos.end;
                  tailoIndex += matchedWords.length;
                  matched = true;
                  break;
                }
              }

              // å¦‚æœæ²’æœ‰åŒ¹é…ï¼ŒæŒ‰éŸ³ç¯€æ•¸è™•ç†
              if (!matched) {
                const syllableCount = item.syllables;
                const segment = chars
                  .slice(charIndex, charIndex + syllableCount)
                  .join("");
                segments.push(segment);
                charIndex += syllableCount;
                tailoIndex++;
              }
            } else {
              // æ­£å¸¸å¤„ç†ï¼šæ ¹æ®éŸ³èŠ‚æ•°åˆ†é…æ¼¢å­—
              const syllableCount = item.syllables;
              const segment = chars
                .slice(charIndex, charIndex + syllableCount)
                .join("");
              segments.push(segment);
              charIndex += syllableCount;
              tailoIndex++;
            }
          }
        }

        if (charIndex < chars.length) {
          const remaining = chars.slice(charIndex).join("");
          for (let i = segments.length - 1; i >= 0; i--) {
            if (!isPunctuation(segments[i])) {
              segments[i] += remaining;
              break;
            }
          }
        }

        return segments;
      }

      // è¾“å…¥æ³•äº‹ä»¶
      function handleCompositionStart(e) {
        isComposing = true;
      }

      function handleCompositionEnd(e) {
        isComposing = false;
      }

      // å‡†å¤‡åŒºæŒ‰é”®
      function handlePrepKeyDown(e) {
        if (e.key === "Enter" && !isComposing) {
          e.preventDefault();
          // ç›´æ¥è·³è½¬åˆ°ç¬¬ä¸€ä¸ªè¾“å…¥æ¡†ï¼Œä¸å¼€å§‹è®¡æ—¶
          const firstInput = document.getElementById("input0");
          if (firstInput) {
            firstInput.focus();
          }

          document.getElementById("prepInput").disabled = true;
        }
      }

      // æ‰“å­—åŒºæŒ‰é”®
      function handleKeyDown(e) {
        const input = e.target;
        const index = parseInt(input.dataset.index);

        // ç¬¬ä¸€æ¬¡æŒ‰é”®æ—¶å¼€å§‹è®¡æ—¶
        if (!isTypingStarted && !isComposing) {
          startTimer();
          isTypingStarted = true;
        }

        if (e.key === "Enter" && !isComposing) {
          e.preventDefault();
          const nextInput = document.getElementById("input" + (index + 1));
          if (nextInput) {
            // è¿˜æœ‰ä¸‹ä¸€ä¸ªè¾“å…¥æ¡†ï¼Œç»§ç»­
            nextInput.focus();
          } else {
            // æœ€åä¸€ä¸ªè¾“å…¥æ¡†ï¼Œè‡ªåŠ¨å®Œæˆç»ƒä¹ 
            finishPractice();
          }
        }
      }

      // è‡ªå‹•èª¿æ•´ textarea é«˜åº¦
      function autoResizeTextarea(textarea) {
        // é‡ç½®é«˜åº¦ä»¥ç²å–æ­£ç¢ºçš„ scrollHeight
        textarea.style.height = "auto";
        // è¨­ç½®æ–°é«˜åº¦ï¼Œè‡³å°‘ä¿æŒæœ€å°é«˜åº¦
        const newHeight = Math.max(textarea.scrollHeight, 50);
        textarea.style.height = newHeight + "px";
      }

      // å¤„ç†è¾“å…¥
      function handleInput(e) {
        const input = e.target;
        const index = parseInt(input.dataset.index);
        const referenceText = paragraphs[index];
        // æ­£è¦åŒ–ç”¨æˆ¶è¼¸å…¥ï¼ˆåŒ…å« Unicode å’Œç™½è©±å­— hâ¿/â¿hï¼‰
        const isPOJ = currentRomanizationSystem === "poj";
        const typedText = normalizeForComparison(input.value, isPOJ);

        // è‡ªå‹•èª¿æ•´é«˜åº¦
        autoResizeTextarea(input);

        // ç¬¬ä¸€æ¬¡è¾“å…¥æ—¶å¼€å§‹è®¡æ—¶
        if (!isTypingStarted && typedText.length > 0) {
          startTimer();
          isTypingStarted = true;
        }

        updateReferenceMarks(index, referenceText, typedText);

        let isCorrect = true;
        for (let i = 0; i < typedText.length; i++) {
          if (typedText[i] !== referenceText[i]) {
            isCorrect = false;
            break;
          }
        }

        if (typedText.length === 0) {
          input.classList.remove("correct");
        } else if (isCorrect) {
          //   input.classList.remove("error");
          input.classList.add("correct");
        } else {
          input.classList.remove("correct");
          //   input.classList.add("error");
        }

        updateStats(referenceText, typedText, index);
      }

      // æ›´æ–°å‚è€ƒæ–‡æœ¬æ ‡è®°
      function updateReferenceMarks(index, referenceText, typedText) {
        const refTextElement = document.getElementById("refText" + index);

        if (inputMode === "hanji") {
          // æ¼¢å­—æ¨¡å¼ï¼šç›´æ¥æŒ‰rubyå…ƒç´ æ¯”å¯¹
          const charMarks = refTextElement.querySelectorAll(".char-mark");
          const charMarksArray = Array.from(charMarks);
          let typedIndex = 0;

          // å…ˆç§»é™¤æ‰€æœ‰èˆŠçš„ç©ºæ ¼éŒ¯èª¤æ¨™è¨˜
          refTextElement
            .querySelectorAll(".space-error")
            .forEach((marker) => marker.remove());

          charMarksArray.forEach((mark, markIndex) => {
            mark.classList.remove("correct", "incorrect");

            // æ¼¢å­—æ¨¡å¼ï¼šè·³éç”¨æˆ¶è¼¸å…¥ä¸­çš„ç©ºæ ¼
            let skippedSpaces = 0;
            while (
              typedIndex < typedText.length &&
              typedText[typedIndex] === " "
            ) {
              typedIndex++;
              skippedSpaces++;
            }

            const rubyTextNodes = Array.from(mark.childNodes).filter(
              (node) =>
                node.nodeType === 3 ||
                (node.nodeType === 1 && node.tagName !== "RT")
            );
            const rubyText = rubyTextNodes
              .map((node) => node.textContent)
              .join("");

            const rubyLength = rubyText.length;
            const typedSegment = typedText.substr(typedIndex, rubyLength);

            // åªæœ‰åœ¨ç”¨æˆ¶å·²ç¶“é–‹å§‹è¼¸å…¥ç•¶å‰Rubyæ™‚ï¼Œæ‰æª¢æŸ¥ç©ºæ ¼éŒ¯èª¤
            if (typedSegment.length > 0 && markIndex > 0) {
              const prevMark = charMarksArray[markIndex - 1];
              const prevRubyTextNodes = Array.from(prevMark.childNodes).filter(
                (node) =>
                  node.nodeType === 3 ||
                  (node.nodeType === 1 && node.tagName !== "RT")
              );
              const prevRubyText = prevRubyTextNodes
                .map((node) => node.textContent)
                .join("");
              const prevIsRomanization =
                /^[a-zA-ZÄÃ¡Ã ÄƒÃ¢ÇÄ“Ã©Ã¨ÃªÄ›Ä«Ã­Ã¬Ä­ÇÅÃ³Ã²ÅÃ´Ç’Å«ÃºÃ¹Å­Ç”Ç–Ç˜ÇšÇœá¸¿Å„ÅˆÃ±á¹á¹…á¹‡á¹‰â¿-]+$/.test(
                  prevRubyText
                );
              const currentIsRomanization =
                /^[a-zA-ZÄÃ¡Ã ÄƒÃ¢ÇÄ“Ã©Ã¨ÃªÄ›Ä«Ã­Ã¬Ä­ÇÅÃ³Ã²ÅÃ´Ç’Å«ÃºÃ¹Å­Ç”Ç–Ç˜ÇšÇœá¸¿Å„ÅˆÃ±á¹á¹…á¹‡á¹‰â¿-]+$/.test(
                  rubyText
                );

              // å¦‚æœå‰ä¸€å€‹å’Œç•¶å‰éƒ½æ˜¯ç¾…é¦¬å­—ï¼Œå¿…é ˆæœ‰ç©ºæ ¼
              if (
                prevIsRomanization &&
                currentIsRomanization &&
                skippedSpaces === 0
              ) {
                // åœ¨ç•¶å‰Rubyä¹‹å‰æ’å…¥ç´…è‰²ç©ºæ ¼æ¨™è¨˜
                const spaceMarker = document.createElement("span");
                spaceMarker.className = "space-error";
                spaceMarker.textContent = "â£";
                spaceMarker.style.color = "red";
                spaceMarker.style.fontWeight = "bold";
                spaceMarker.style.fontSize = "20px";
                mark.parentNode.insertBefore(spaceMarker, mark);

                // æ¨™è¨˜ç•¶å‰ç‚ºéŒ¯èª¤
                mark.classList.add("incorrect");
              }
            }

            if (typedSegment.length === rubyLength) {
              // ä½¿ç”¨ç¶œåˆæ­£è¦åŒ–é€²è¡Œæ¯”è¼ƒï¼ˆåŒ…å« Unicode å’Œç™½è©±å­— hâ¿/â¿hï¼‰
              const isPOJ = currentRomanizationSystem === "poj";
              if (
                normalizeForComparison(typedSegment, isPOJ) ===
                normalizeForComparison(rubyText, isPOJ)
              ) {
                // åªæœ‰åœ¨æ²’æœ‰è¢«æ¨™è¨˜ç‚ºéŒ¯èª¤æ™‚æ‰æ¨™è¨˜ç‚ºæ­£ç¢º
                if (!mark.classList.contains("incorrect")) {
                  mark.classList.add("correct");
                }
              } else {
                mark.classList.add("incorrect");
              }
            } else if (typedSegment.length > 0) {
              mark.classList.add("incorrect");
            }

            typedIndex += rubyLength;
          });
        } else {
          // å°ç¾…æ¨¡å¼ï¼šéæ­·æ‰€æœ‰ char-mark ä¸¦ä¾åºæ¯”å°
          const charMarks = refTextElement.querySelectorAll(".char-mark");
          let typedIndex = 0;

          charMarks.forEach((mark) => {
            mark.classList.remove("correct", "incorrect");

            const rubyTextNodes = Array.from(mark.childNodes).filter(
              (node) =>
                node.nodeType === 3 ||
                (node.nodeType === 1 && node.tagName !== "RT")
            );
            const rubyText = rubyTextNodes
              .map((node) => node.textContent)
              .join("");

            // å°ç¾…æ¨¡å¼ï¼šè·³éç”¨æˆ¶è¼¸å…¥ä¸­çš„ç©ºæ ¼
            while (
              typedIndex < typedText.length &&
              typedText[typedIndex] === " "
            ) {
              typedIndex++;
            }

            // å¾ç•¶å‰ä½ç½®æå–èˆ‡ rubyText é•·åº¦ç›¸åŒçš„è¼¸å…¥
            const typedSegment = typedText.substr(typedIndex, rubyText.length);

            if (typedSegment.length === rubyText.length) {
              // ä½¿ç”¨ç¶œåˆæ­£è¦åŒ–é€²è¡Œæ¯”è¼ƒï¼ˆåŒ…å« Unicode å’Œç™½è©±å­— hâ¿/â¿hï¼‰
              const isPOJ = currentRomanizationSystem === "poj";
              if (
                normalizeForComparison(typedSegment, isPOJ) ===
                normalizeForComparison(rubyText, isPOJ)
              ) {
                mark.classList.add("correct");
              } else {
                mark.classList.add("incorrect");
              }
            } else if (typedSegment.length > 0) {
              mark.classList.add("incorrect");
            }

            typedIndex += rubyText.length;
          });
        }
      }

      // æ›´æ–°ç»Ÿè®¡
      function updateStats(referenceText, typedText, paragraphIndex) {
        // è¨ˆç®—ç•¶å‰æ®µè½çš„æ­£ç¢ºå’ŒéŒ¯èª¤éŸ³ç¯€æ•¸
        const refTextElement = document.getElementById(
          "refText" + paragraphIndex
        );
        const charMarks = refTextElement.querySelectorAll(".char-mark");

        let correct = 0;
        let errors = 0;

        // çµ±è¨ˆç•¶å‰æ®µè½ä¸­æ­£ç¢ºå’ŒéŒ¯èª¤çš„éŸ³ç¯€
        charMarks.forEach((mark) => {
          const syllableCount = getSyllableCountFromMark(mark);

          if (mark.classList.contains("correct")) {
            correct += syllableCount;
          } else if (mark.classList.contains("incorrect")) {
            errors += syllableCount;
          }
        });

        // è¨ˆç®—æ‰€æœ‰æ®µè½çš„å·²æ‰“éŸ³ç¯€æ•¸
        let totalTypedSyllables = 0;
        document.querySelectorAll(".typing-input").forEach((input, idx) => {
          const refText = document.getElementById("refText" + idx);
          const marks = refText.querySelectorAll(".char-mark");
          marks.forEach((mark) => {
            if (
              mark.classList.contains("correct") ||
              mark.classList.contains("incorrect")
            ) {
              totalTypedSyllables += getSyllableCountFromMark(mark);
            }
          });
        });

        const missed = stats.totalChars - totalTypedSyllables;

        document.getElementById("correctDisplay").textContent = correct;
        document.getElementById("errorDisplay").textContent = errors;
        document.getElementById("missedDisplay").textContent = Math.max(
          0,
          missed
        );

        if (stats.elapsedTime > 0) {
          const speed = Math.round(
            (totalTypedSyllables / stats.elapsedTime) * 60
          );
          document.getElementById("speedDisplay").textContent = speed;
        }

        stats.correct = correct;
        stats.errors = errors;
        stats.missed = Math.max(0, missed);
      }

      // è®¡æ—¶å™¨
      function startTimer() {
        stats.startTime = Date.now();
        timerInterval = setInterval(() => {
          stats.elapsedTime = Math.floor((Date.now() - stats.startTime) / 1000);
          updateTimeDisplay();
        }, 1000);
      }

      function updateTimeDisplay() {
        const minutes = Math.floor(stats.elapsedTime / 60);
        const seconds = stats.elapsedTime % 60;
        document.getElementById("timeDisplay").textContent =
          minutes + ":" + (seconds < 10 ? "0" : "") + seconds;
      }

      // é‡ç½®ç»Ÿè®¡
      function resetStats() {
        stats = {
          startTime: null,
          elapsedTime: 0,
          correct: 0,
          errors: 0,
          missed: stats.totalChars,
          totalChars: stats.totalChars,
        };
        isTypingStarted = false;
        isComposing = false;

        document.getElementById("timeDisplay").textContent = "0:00";
        document.getElementById("correctDisplay").textContent = "0";
        document.getElementById("errorDisplay").textContent = "0";
        document.getElementById("missedDisplay").textContent = stats.totalChars;
        document.getElementById("speedDisplay").textContent = "0";

        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }
      }

      // ç»“æŸç»ƒä¹ 
      function finishPractice() {
        if (timerInterval) {
          clearInterval(timerInterval);
        }

        let totalCorrect = 0;
        let totalErrors = 0;
        let totalTypedSyllables = 0;

        // çµ±è¨ˆæ‰€æœ‰æ®µè½çš„éŸ³ç¯€æ•¸
        document.querySelectorAll(".typing-input").forEach((input, index) => {
          const refText = document.getElementById("refText" + index);
          const charMarks = refText.querySelectorAll(".char-mark");

          charMarks.forEach((mark) => {
            const syllableCount = getSyllableCountFromMark(mark);

            if (mark.classList.contains("correct")) {
              totalCorrect += syllableCount;
              totalTypedSyllables += syllableCount;
            } else if (mark.classList.contains("incorrect")) {
              totalErrors += syllableCount;
              totalTypedSyllables += syllableCount;
            }
          });
        });

        const totalMissed = stats.totalChars - totalTypedSyllables;
        const accuracy =
          stats.totalChars > 0
            ? ((totalCorrect / stats.totalChars) * 100).toFixed(1)
            : 0;
        const speed =
          stats.elapsedTime > 0
            ? Math.round((totalTypedSyllables / stats.elapsedTime) * 60)
            : 0;

        const timeText = document.getElementById("timeDisplay").textContent;

        let htmlContent =
          '<div class="speed-main">' +
          speed +
          ' <span class="speed-unit">éŸ³ç¯€/åˆ†</span></div>' +
          '<div class="stats-details">' +
          '<div class="detail-row">' +
          '<span class="detail-label">æ­£ç¢ºï¼š</span>' +
          '<span class="detail-value" style="color: var(--link-color)">' +
          totalCorrect +
          "</span>" +
          '<span class="detail-divider">|</span>' +
          '<span class="detail-label">éŒ¯èª¤ï¼š</span>' +
          '<span class="detail-value" style="color: #c44">' +
          totalErrors +
          "</span>" +
          '<span class="detail-divider">|</span>' +
          '<span class="detail-label">æ­£ç¢ºç‡ï¼š</span>' +
          '<span class="detail-value">' +
          accuracy +
          "%</span>" +
          "</div>" +
          '<div class="detail-row">' +
          '<span class="detail-label">ç”¨æ™‚ï¼š</span>' +
          '<span class="detail-value">' +
          timeText +
          "</span>" +
          '<span class="detail-divider">|</span>' +
          '<span class="detail-label">ç¸½éŸ³ç¯€ï¼š</span>' +
          '<span class="detail-value">' +
          stats.totalChars +
          "</span>" +
          '<span class="detail-divider">|</span>' +
          '<span class="detail-label">å®Œæˆï¼š</span>' +
          '<span class="detail-value">' +
          totalTypedSyllables +
          "</span>" +
          "</div>";

        // å¦‚æœæ˜¯éš¨æ©Ÿæ¨¡å¼ï¼Œé¡¯ç¤ºç¨®å­ç¢¼
        if (isRandomMode && currentSeed) {
          const sentenceCount = document.getElementById("randomCount").value;
          htmlContent +=
            '<div class="seed-info">' +
            '<span class="seed-label">Seedï¼š</span>' +
            '<code class="seed-code">' +
            currentSeed +
            "</code>" +
            '<span class="seed-hint">ï¼ˆä¾‹å¥æ•¸é‡ï¼š' +
            sentenceCount +
            "ï¼‰</span>" +
            "</div>";
        }

        htmlContent += "</div>";

        document.getElementById("resultStats").innerHTML = htmlContent;

        document.getElementById("resultModal").classList.add("active");
      }

      // å…³é—­ç»“æœ
      function closeResult() {
        document.getElementById("resultModal").classList.remove("active");

        document.getElementById("setupArea").style.display = "block";
        document.getElementById("statsBar").classList.remove("active");
        document.getElementById("practiceArea").classList.remove("active");

        document.getElementById("typingSections").innerHTML = "";

        const prepInput = document.getElementById("prepInput");
        if (prepInput) {
          prepInput.value = "";
          prepInput.disabled = false;
        }

        hanjiParagraphs = [];
        tailoParagraphs = [];
        paragraphs = [];

        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }

        stats = {
          startTime: null,
          elapsedTime: 0,
          correct: 0,
          errors: 0,
          missed: 0,
          totalChars: 0,
        };
        isTypingStarted = false;
        isComposing = false;

        document.getElementById("timeDisplay").textContent = "0:00";
        document.getElementById("correctDisplay").textContent = "0";
        document.getElementById("errorDisplay").textContent = "0";
        document.getElementById("missedDisplay").textContent = "0";
        document.getElementById("speedDisplay").textContent = "0";
      }

      // è¨ˆç®—å–®å€‹ char-mark çš„éŸ³ç¯€æ•¸
      function getSyllableCountFromMark(mark) {
        const rubyTextNodes = Array.from(mark.childNodes).filter(
          (node) =>
            node.nodeType === 3 ||
            (node.nodeType === 1 && node.tagName !== "RT")
        );
        const text = rubyTextNodes.map((node) => node.textContent).join("");

        // æª¢æŸ¥æ˜¯å¦ç‚º span æ¨™ç±¤ï¼ˆå–®ä¸€æ–‡æœ¬æ¨¡å¼ï¼‰
        if (mark.tagName === "SPAN") {
          // æª¢æŸ¥æ˜¯å¦ç‚ºæ¨™é»ç¬¦è™Ÿ mark
          if (mark.classList.contains("punctuation-mark")) {
            return 0; // æ¨™é»ç¬¦è™Ÿä¸è¨ˆå…¥éŸ³ç¯€æ•¸
          }

          // å–®ä¸€æ–‡æœ¬æ¨¡å¼ï¼šéœ€è¦åˆ¤æ–·å…§å®¹é¡å‹

          // å¦‚æœæ˜¯æ¼¢å­—ï¼Œè¨ˆç®—æ¼¢å­—æ•¸é‡
          if (
            isHanjiChar(text.charAt(0)) ||
            (text.length >= 2 &&
              text.charCodeAt(0) >= 0xd800 &&
              text.charCodeAt(0) <= 0xdbff)
          ) {
            return countHanjiChars(text);
          }

          // å¦‚æœæ˜¯æ•¸å­—ï¼Œç®—1å€‹
          if (/^\d+$/.test(text)) {
            return 1;
          }

          // å¦‚æœæ˜¯ç¾…é¦¬å­—ï¼ŒæŒ‰é€£å­—ç¬¦è™Ÿåˆ†éš”è¨ˆç®—éŸ³ç¯€
          const normalized = text.replace(/--/g, "-");
          const syllables = normalized.split("-").filter((s) => s.length > 0);
          return syllables.length;
        }

        if (inputMode === "hanji") {
          // æ¼¢å­—æ¨¡å¼ï¼šè¨ˆç®—æ¼¢å­—æ•¸é‡ï¼ˆåŒ…æ‹¬ä»£ç†å°ï¼‰
          return countHanjiChars(text);
        } else {
          // å°ç¾…æ¨¡å¼ï¼šè¨ˆç®—é€£å­—ç¬¦è™Ÿåˆ†éš”çš„éŸ³ç¯€æ•¸
          const cleanText = text.trim();
          if (cleanText.length === 0) return 0;

          // å…ˆæ›¿æ› -- ç‚ºå–®ä¸€åˆ†éš”ç¬¦
          const normalized = cleanText.replace(/--/g, "-");
          const syllables = normalized.split("-").filter((s) => s.length > 0);
          return syllables.length;
        }
      }

      // è¨ˆç®—æ¼¢å­—æ•¸é‡ï¼ˆæ­£ç¢ºè™•ç†ä»£ç†å°ï¼‰
      function countHanjiChars(text) {
        let count = 0;
        let i = 0;

        while (i < text.length) {
          const char = text[i];
          const code = char.charCodeAt(0);

          // æª¢æŸ¥æ˜¯å¦ç‚ºé«˜ä»£ç†é …
          if (code >= 0xd800 && code <= 0xdbff) {
            // é€™æ˜¯ä»£ç†å°çš„é–‹å§‹ï¼Œç®—ä½œä¸€å€‹æ¼¢å­—
            count++;
            i += 2; // è·³éä½ä»£ç†é …
          } else if (isHanjiChar(char)) {
            // æ™®é€š BMP æ¼¢å­—
            count++;
            i++;
          } else {
            // éæ¼¢å­—å­—ç¬¦ï¼Œè·³é
            i++;
          }
        }

        return count;
      }

      // è¨ˆç®—éŸ³ç¯€æ•¸ï¼ˆå¾ DOM å…ƒç´ è¨ˆç®—ï¼‰
      function countSyllablesFromDOM(containerElement) {
        const charMarks = containerElement.querySelectorAll(".char-mark");
        let totalSyllables = 0;

        charMarks.forEach((mark) => {
          totalSyllables += getSyllableCountFromMark(mark);
        });

        return totalSyllables;
      }

      // HTMLè½¬ä¹‰
      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // ========== é™¤éŒ¯ç”¨ç§˜æŠ€ ==========
      // åœ¨ console è¼¸å…¥ä»¥ä¸‹æŒ‡ä»¤ä¾†æ§åˆ¶è²¼ä¸ŠåŠŸèƒ½ï¼š
      //
      // å•Ÿç”¨è²¼ä¸Šï¼šwindow.enablePaste() æˆ– window.allowPaste = true
      // åœç”¨è²¼ä¸Šï¼šwindow.disablePaste() æˆ– window.allowPaste = false
      // æŸ¥çœ‹ç‹€æ…‹ï¼šwindow.checkPasteStatus()
      //
      window.enablePaste = function () {
        allowPaste = true;
        console.log("âœ… è²¼ä¸ŠåŠŸèƒ½å·²å•Ÿç”¨ï¼ˆé™¤éŒ¯æ¨¡å¼ï¼‰");
        return allowPaste;
      };

      window.disablePaste = function () {
        allowPaste = false;
        console.log("ğŸš« è²¼ä¸ŠåŠŸèƒ½å·²åœç”¨");
        return allowPaste;
      };

      window.checkPasteStatus = function () {
        console.log(allowPaste ? "âœ… è²¼ä¸ŠåŠŸèƒ½ï¼šå·²å•Ÿç”¨" : "ğŸš« è²¼ä¸ŠåŠŸèƒ½ï¼šå·²åœç”¨");
        return allowPaste;
      };

      // å°‡ allowPaste è®Šæ•¸æš´éœ²åˆ° window ç‰©ä»¶ï¼Œæ–¹ä¾¿ç›´æ¥è¨­å®š
      Object.defineProperty(window, "allowPaste", {
        get: function () {
          return allowPaste;
        },
        set: function (value) {
          allowPaste = value;
          console.log(
            value ? "âœ… è²¼ä¸ŠåŠŸèƒ½å·²å•Ÿç”¨ï¼ˆé™¤éŒ¯æ¨¡å¼ï¼‰" : "ğŸš« è²¼ä¸ŠåŠŸèƒ½å·²åœç”¨"
          );
        },
        configurable: true,
      });

      // æ›´æ–°æ–‡ç« ç¸½æ•¸é¡¯ç¤º
      function updateArticleCount() {
        const articleCountElement = document.getElementById("articleCount");
        if (articleCountElement && typeof articles !== "undefined") {
          articleCountElement.textContent = articles.length;
        }
      }

      // ç•¶æ‰€æœ‰è³‡æºï¼ˆåŒ…æ‹¬ articles.jsï¼‰è¼‰å…¥å®Œæˆå¾Œæ›´æ–°æ–‡ç« ç¸½æ•¸
      if (window.addEventListener) {
        window.addEventListener("load", updateArticleCount);
      } else if (window.attachEvent) {
        window.attachEvent("onload", updateArticleCount);
      } else {
        // å¦‚æœäº‹ä»¶ç›£è½å™¨ä¸å¯ç”¨ï¼Œç›´æ¥å˜—è©¦æ›´æ–°ï¼ˆé©ç”¨æ–¼ articles.js åŒæ­¥è¼‰å…¥çš„æƒ…æ³ï¼‰
        setTimeout(updateArticleCount, 100);
      }
    </script>
  </body>
</html>
